/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 0.0.0\n\nOptional extensions on the jquery.inputmask base\n*/\n(function ($) {\n    //extra definitions\n    $.extend($.inputmask.defaults.definitions, {\n        'A': {\n            validator: \"[A-Za-z]\",\n            cardinality: 1,\n            casing: \"upper\" //auto uppercasing\n        },\n        '#': {\n            validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u04510-9]\",\n            cardinality: 1,\n            casing: \"upper\"\n        }\n    });\n    $.extend($.inputmask.defaults.aliases, {\n        'url': {\n            mask: \"ir\",\n            placeholder: \"\",\n            separator: \"\",\n            defaultPrefix: \"http://\",\n            regex: {\n                urlpre1: new RegExp(\"[fh]\"),\n                urlpre2: new RegExp(\"(ft|ht)\"),\n                urlpre3: new RegExp(\"(ftp|htt)\"),\n                urlpre4: new RegExp(\"(ftp:|http|ftps)\"),\n                urlpre5: new RegExp(\"(ftp:/|ftps:|http:|https)\"),\n                urlpre6: new RegExp(\"(ftp://|ftps:/|http:/|https:)\"),\n                urlpre7: new RegExp(\"(ftp://|ftps://|http://|https:/)\"),\n                urlpre8: new RegExp(\"(ftp://|ftps://|http://|https://)\")\n            },\n            definitions: {\n                'i': {\n                    validator: function (chrs, buffer, pos, strict, opts) {\n                        return true;\n                    },\n                    cardinality: 8,\n                    prevalidator: (function () {\n                        var result = [], prefixLimit = 8;\n                        for (var i = 0; i < prefixLimit; i++) {\n                            result[i] = (function () {\n                                var j = i;\n                                return {\n                                    validator: function (chrs, buffer, pos, strict, opts) {\n                                        if (opts.regex[\"urlpre\" + (j + 1)]) {\n                                            var tmp = chrs, k;\n                                            if (((j + 1) - chrs.length) > 0) {\n                                                tmp = buffer.join('').substring(0, ((j + 1) - chrs.length)) + \"\" + tmp;\n                                            }\n                                            var isValid = opts.regex[\"urlpre\" + (j + 1)].test(tmp);\n                                            if (!strict && !isValid) {\n                                                pos = pos - j;\n                                                for (k = 0; k < opts.defaultPrefix.length; k++) {\n                                                    buffer[pos] = opts.defaultPrefix[k]; pos++;\n                                                }\n                                                for (k = 0; k < tmp.length - 1; k++) {\n                                                    buffer[pos] = tmp[k]; pos++;\n                                                }\n                                                return { \"pos\": pos };\n                                            }\n                                            return isValid;\n                                        } else {\n                                            return false;\n                                        }\n                                    }, cardinality: j\n                                };\n                            })();\n                        }\n                        return result;\n                    })()\n                },\n                \"r\": {\n                    validator: \".\",\n                    cardinality: 50\n                }\n            },\n            insertMode: false,\n            autoUnmask: false\n        },\n        \"ip\": { //ip-address mask\n            mask: [\"[[x]y]z.[[x]y]z.[[x]y]z.x[yz]\", \"[[x]y]z.[[x]y]z.[[x]y]z.[[x]y][z]\"],\n            definitions: {\n                'x': {\n                    validator: \"[012]\",\n                    cardinality: 1,\n                    definitionSymbol: \"i\"\n                },\n                'y': {\n                    validator: function (chrs, buffer, pos, strict, opts) {\n                        if (pos - 1 > -1 && buffer[pos - 1] != \".\")\n                            chrs = buffer[pos - 1] + chrs;\n                        else chrs = \"0\" + chrs;\n                        return new RegExp(\"2[0-5]|[01][0-9]\").test(chrs);\n                    },\n                    cardinality: 1,\n                    definitionSymbol: \"i\"\n                },\n                'z': {\n                    validator: function (chrs, buffer, pos, strict, opts) {\n                        if (pos - 1 > -1 && buffer[pos - 1] != \".\") {\n                            chrs = buffer[pos - 1] + chrs;\n                            if (pos - 2 > -1 && buffer[pos - 2] != \".\") {\n                                chrs = buffer[pos - 2] + chrs;\n                            } else chrs = \"0\" + chrs;\n                        } else chrs = \"00\" + chrs;\n                        return new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\n                    },\n                    cardinality: 1,\n                    definitionSymbol: \"i\"\n                }\n            }\n        }\n    });\n})(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2Jvd2VyL0FkbWluTFRFL3BsdWdpbnMvaW5wdXQtbWFzay9qcXVlcnkuaW5wdXRtYXNrLmV4dGVuc2lvbnMuanM/YjYwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuSW5wdXQgTWFzayBwbHVnaW4gZXh0ZW5zaW9uc1xuaHR0cDovL2dpdGh1Yi5jb20vUm9iaW5IZXJib3RzL2pxdWVyeS5pbnB1dG1hc2tcbkNvcHlyaWdodCAoYykgMjAxMCAtIDIwMTQgUm9iaW4gSGVyYm90c1xuTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcblZlcnNpb246IDAuMC4wXG5cbk9wdGlvbmFsIGV4dGVuc2lvbnMgb24gdGhlIGpxdWVyeS5pbnB1dG1hc2sgYmFzZVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIC8vZXh0cmEgZGVmaW5pdGlvbnNcbiAgICAkLmV4dGVuZCgkLmlucHV0bWFzay5kZWZhdWx0cy5kZWZpbml0aW9ucywge1xuICAgICAgICAnQSc6IHtcbiAgICAgICAgICAgIHZhbGlkYXRvcjogXCJbQS1aYS16XVwiLFxuICAgICAgICAgICAgY2FyZGluYWxpdHk6IDEsXG4gICAgICAgICAgICBjYXNpbmc6IFwidXBwZXJcIiAvL2F1dG8gdXBwZXJjYXNpbmdcbiAgICAgICAgfSxcbiAgICAgICAgJyMnOiB7XG4gICAgICAgICAgICB2YWxpZGF0b3I6IFwiW0EtWmEtelxcdTA0MTAtXFx1MDQ0RlxcdTA0MDFcXHUwNDUxMC05XVwiLFxuICAgICAgICAgICAgY2FyZGluYWxpdHk6IDEsXG4gICAgICAgICAgICBjYXNpbmc6IFwidXBwZXJcIlxuICAgICAgICB9XG4gICAgfSk7XG4gICAgJC5leHRlbmQoJC5pbnB1dG1hc2suZGVmYXVsdHMuYWxpYXNlcywge1xuICAgICAgICAndXJsJzoge1xuICAgICAgICAgICAgbWFzazogXCJpclwiLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiXCIsXG4gICAgICAgICAgICBzZXBhcmF0b3I6IFwiXCIsXG4gICAgICAgICAgICBkZWZhdWx0UHJlZml4OiBcImh0dHA6Ly9cIixcbiAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgdXJscHJlMTogbmV3IFJlZ0V4cChcIltmaF1cIiksXG4gICAgICAgICAgICAgICAgdXJscHJlMjogbmV3IFJlZ0V4cChcIihmdHxodClcIiksXG4gICAgICAgICAgICAgICAgdXJscHJlMzogbmV3IFJlZ0V4cChcIihmdHB8aHR0KVwiKSxcbiAgICAgICAgICAgICAgICB1cmxwcmU0OiBuZXcgUmVnRXhwKFwiKGZ0cDp8aHR0cHxmdHBzKVwiKSxcbiAgICAgICAgICAgICAgICB1cmxwcmU1OiBuZXcgUmVnRXhwKFwiKGZ0cDovfGZ0cHM6fGh0dHA6fGh0dHBzKVwiKSxcbiAgICAgICAgICAgICAgICB1cmxwcmU2OiBuZXcgUmVnRXhwKFwiKGZ0cDovL3xmdHBzOi98aHR0cDovfGh0dHBzOilcIiksXG4gICAgICAgICAgICAgICAgdXJscHJlNzogbmV3IFJlZ0V4cChcIihmdHA6Ly98ZnRwczovL3xodHRwOi8vfGh0dHBzOi8pXCIpLFxuICAgICAgICAgICAgICAgIHVybHByZTg6IG5ldyBSZWdFeHAoXCIoZnRwOi8vfGZ0cHM6Ly98aHR0cDovL3xodHRwczovLylcIilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAgICAgICAgICdpJzoge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIChjaHJzLCBidWZmZXIsIHBvcywgc3RyaWN0LCBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FyZGluYWxpdHk6IDgsXG4gICAgICAgICAgICAgICAgICAgIHByZXZhbGlkYXRvcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgcHJlZml4TGltaXQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhMaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAoY2hycywgYnVmZmVyLCBwb3MsIHN0cmljdCwgb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlZ2V4W1widXJscHJlXCIgKyAoaiArIDEpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gY2hycywgaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoaiArIDEpIC0gY2hycy5sZW5ndGgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gYnVmZmVyLmpvaW4oJycpLnN1YnN0cmluZygwLCAoKGogKyAxKSAtIGNocnMubGVuZ3RoKSkgKyBcIlwiICsgdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gb3B0cy5yZWdleFtcInVybHByZVwiICsgKGogKyAxKV0udGVzdCh0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zIC0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBvcHRzLmRlZmF1bHRQcmVmaXgubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbcG9zXSA9IG9wdHMuZGVmYXVsdFByZWZpeFtrXTsgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdG1wLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwb3NdID0gdG1wW2tdOyBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IFwicG9zXCI6IHBvcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjYXJkaW5hbGl0eTogalxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJcIjoge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICBjYXJkaW5hbGl0eTogNTBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zZXJ0TW9kZTogZmFsc2UsXG4gICAgICAgICAgICBhdXRvVW5tYXNrOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImlwXCI6IHsgLy9pcC1hZGRyZXNzIG1hc2tcbiAgICAgICAgICAgIG1hc2s6IFtcIltbeF15XXouW1t4XXldei5bW3hdeV16LnhbeXpdXCIsIFwiW1t4XXldei5bW3hdeV16LltbeF15XXouW1t4XXldW3pdXCJdLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAneCc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIlswMTJdXCIsXG4gICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcImlcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3knOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKGNocnMsIGJ1ZmZlciwgcG9zLCBzdHJpY3QsIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgLSAxID4gLTEgJiYgYnVmZmVyW3BvcyAtIDFdICE9IFwiLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocnMgPSBidWZmZXJbcG9zIC0gMV0gKyBjaHJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBjaHJzID0gXCIwXCIgKyBjaHJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIyWzAtNV18WzAxXVswLTldXCIpLnRlc3QoY2hycyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uU3ltYm9sOiBcImlcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3onOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKGNocnMsIGJ1ZmZlciwgcG9zLCBzdHJpY3QsIG9wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgLSAxID4gLTEgJiYgYnVmZmVyW3BvcyAtIDFdICE9IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hycyA9IGJ1ZmZlcltwb3MgLSAxXSArIGNocnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAtIDIgPiAtMSAmJiBidWZmZXJbcG9zIC0gMl0gIT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hycyA9IGJ1ZmZlcltwb3MgLSAyXSArIGNocnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGNocnMgPSBcIjBcIiArIGNocnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgY2hycyA9IFwiMDBcIiArIGNocnM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIjI1WzAtNV18MlswLTRdWzAtOV18WzAxXVswLTldWzAtOV1cIikudGVzdChjaHJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FyZGluYWxpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25TeW1ib2w6IFwiaVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KShqUXVlcnkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvYm93ZXIvQWRtaW5MVEUvcGx1Z2lucy9pbnB1dC1tYXNrL2pxdWVyeS5pbnB1dG1hc2suZXh0ZW5zaW9ucy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

eval("/**\n* @license Input Mask plugin for jquery\n* http://github.com/RobinHerbots/jquery.inputmask\n* Copyright (c) 2010 - 2014 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 0.0.0\n*/\n\n(function ($) {\n    if ($.fn.inputmask === undefined) {\n        //helper functions    \n        function isInputEventSupported(eventName) {\n            var el = document.createElement('input'),\n            eventName = 'on' + eventName,\n            isSupported = (eventName in el);\n            if (!isSupported) {\n                el.setAttribute(eventName, 'return;');\n                isSupported = typeof el[eventName] == 'function';\n            }\n            el = null;\n            return isSupported;\n        }\n        function resolveAlias(aliasStr, options, opts) {\n            var aliasDefinition = opts.aliases[aliasStr];\n            if (aliasDefinition) {\n                if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\n                $.extend(true, opts, aliasDefinition);  //merge alias definition in the options\n                $.extend(true, opts, options);  //reapply extra given options\n                return true;\n            }\n            return false;\n        }\n        function generateMaskSets(opts) {\n            var ms = [];\n            var genmasks = []; //used to keep track of the masks that where processed, to avoid duplicates\n            function getMaskTemplate(mask) {\n                if (opts.numericInput) {\n                    mask = mask.split('').reverse().join('');\n                }\n                var escaped = false, outCount = 0, greedy = opts.greedy, repeat = opts.repeat;\n                if (repeat == \"*\") greedy = false;\n                //if (greedy == true && opts.placeholder == \"\") opts.placeholder = \" \";\n                if (mask.length == 1 && greedy == false && repeat != 0) { opts.placeholder = \"\"; } //hide placeholder with single non-greedy mask\n                var singleMask = $.map(mask.split(\"\"), function (element, index) {\n                    var outElem = [];\n                    if (element == opts.escapeChar) {\n                        escaped = true;\n                    }\n                    else if ((element != opts.optionalmarker.start && element != opts.optionalmarker.end) || escaped) {\n                        var maskdef = opts.definitions[element];\n                        if (maskdef && !escaped) {\n                            for (var i = 0; i < maskdef.cardinality; i++) {\n                                outElem.push(opts.placeholder.charAt((outCount + i) % opts.placeholder.length));\n                            }\n                        } else {\n                            outElem.push(element);\n                            escaped = false;\n                        }\n                        outCount += outElem.length;\n                        return outElem;\n                    }\n                });\n\n                //allocate repetitions\n                var repeatedMask = singleMask.slice();\n                for (var i = 1; i < repeat && greedy; i++) {\n                    repeatedMask = repeatedMask.concat(singleMask.slice());\n                }\n\n                return { \"mask\": repeatedMask, \"repeat\": repeat, \"greedy\": greedy };\n            }\n            //test definition => {fn: RegExp/function, cardinality: int, optionality: bool, newBlockMarker: bool, offset: int, casing: null/upper/lower, def: definitionSymbol}\n            function getTestingChain(mask) {\n                if (opts.numericInput) {\n                    mask = mask.split('').reverse().join('');\n                }\n                var isOptional = false, escaped = false;\n                var newBlockMarker = false; //indicates wheter the begin/ending of a block should be indicated\n\n                return $.map(mask.split(\"\"), function (element, index) {\n                    var outElem = [];\n\n                    if (element == opts.escapeChar) {\n                        escaped = true;\n                    } else if (element == opts.optionalmarker.start && !escaped) {\n                        isOptional = true;\n                        newBlockMarker = true;\n                    }\n                    else if (element == opts.optionalmarker.end && !escaped) {\n                        isOptional = false;\n                        newBlockMarker = true;\n                    }\n                    else {\n                        var maskdef = opts.definitions[element];\n                        if (maskdef && !escaped) {\n                            var prevalidators = maskdef[\"prevalidator\"], prevalidatorsL = prevalidators ? prevalidators.length : 0;\n                            for (var i = 1; i < maskdef.cardinality; i++) {\n                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator[\"validator\"], cardinality = prevalidator[\"cardinality\"];\n                                outElem.push({ fn: validator ? typeof validator == 'string' ? new RegExp(validator) : new function () { this.test = validator; } : new RegExp(\".\"), cardinality: cardinality ? cardinality : 1, optionality: isOptional, newBlockMarker: isOptional == true ? newBlockMarker : false, offset: 0, casing: maskdef[\"casing\"], def: maskdef[\"definitionSymbol\"] || element });\n                                if (isOptional == true) //reset newBlockMarker\n                                    newBlockMarker = false;\n                            }\n                            outElem.push({ fn: maskdef.validator ? typeof maskdef.validator == 'string' ? new RegExp(maskdef.validator) : new function () { this.test = maskdef.validator; } : new RegExp(\".\"), cardinality: maskdef.cardinality, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: maskdef[\"casing\"], def: maskdef[\"definitionSymbol\"] || element });\n                        } else {\n                            outElem.push({ fn: null, cardinality: 0, optionality: isOptional, newBlockMarker: newBlockMarker, offset: 0, casing: null, def: element });\n                            escaped = false;\n                        }\n                        //reset newBlockMarker\n                        newBlockMarker = false;\n                        return outElem;\n                    }\n                });\n            }\n            function markOptional(maskPart) { //needed for the clearOptionalTail functionality\n                return opts.optionalmarker.start + maskPart + opts.optionalmarker.end;\n            }\n            function splitFirstOptionalEndPart(maskPart) {\n                var optionalStartMarkers = 0, optionalEndMarkers = 0, mpl = maskPart.length;\n                for (var i = 0; i < mpl; i++) {\n                    if (maskPart.charAt(i) == opts.optionalmarker.start) {\n                        optionalStartMarkers++;\n                    }\n                    if (maskPart.charAt(i) == opts.optionalmarker.end) {\n                        optionalEndMarkers++;\n                    }\n                    if (optionalStartMarkers > 0 && optionalStartMarkers == optionalEndMarkers)\n                        break;\n                }\n                var maskParts = [maskPart.substring(0, i)];\n                if (i < mpl) {\n                    maskParts.push(maskPart.substring(i + 1, mpl));\n                }\n                return maskParts;\n            }\n            function splitFirstOptionalStartPart(maskPart) {\n                var mpl = maskPart.length;\n                for (var i = 0; i < mpl; i++) {\n                    if (maskPart.charAt(i) == opts.optionalmarker.start) {\n                        break;\n                    }\n                }\n                var maskParts = [maskPart.substring(0, i)];\n                if (i < mpl) {\n                    maskParts.push(maskPart.substring(i + 1, mpl));\n                }\n                return maskParts;\n            }\n            function generateMask(maskPrefix, maskPart, metadata) {\n                var maskParts = splitFirstOptionalEndPart(maskPart);\n                var newMask, maskTemplate;\n\n                var masks = splitFirstOptionalStartPart(maskParts[0]);\n                if (masks.length > 1) {\n                    newMask = maskPrefix + masks[0] + markOptional(masks[1]) + (maskParts.length > 1 ? maskParts[1] : \"\");\n                    if ($.inArray(newMask, genmasks) == -1 && newMask != \"\") {\n                        genmasks.push(newMask);\n                        maskTemplate = getMaskTemplate(newMask);\n                        ms.push({\n                            \"mask\": newMask,\n                            \"_buffer\": maskTemplate[\"mask\"],\n                            \"buffer\": maskTemplate[\"mask\"].slice(),\n                            \"tests\": getTestingChain(newMask),\n                            \"lastValidPosition\": -1,\n                            \"greedy\": maskTemplate[\"greedy\"],\n                            \"repeat\": maskTemplate[\"repeat\"],\n                            \"metadata\": metadata\n                        });\n                    }\n                    newMask = maskPrefix + masks[0] + (maskParts.length > 1 ? maskParts[1] : \"\");\n                    if ($.inArray(newMask, genmasks) == -1 && newMask != \"\") {\n                        genmasks.push(newMask);\n                        maskTemplate = getMaskTemplate(newMask);\n                        ms.push({\n                            \"mask\": newMask,\n                            \"_buffer\": maskTemplate[\"mask\"],\n                            \"buffer\": maskTemplate[\"mask\"].slice(),\n                            \"tests\": getTestingChain(newMask),\n                            \"lastValidPosition\": -1,\n                            \"greedy\": maskTemplate[\"greedy\"],\n                            \"repeat\": maskTemplate[\"repeat\"],\n                            \"metadata\": metadata\n                        });\n                    }\n                    if (splitFirstOptionalStartPart(masks[1]).length > 1) { //optional contains another optional\n                        generateMask(maskPrefix + masks[0], masks[1] + maskParts[1], metadata);\n                    }\n                    if (maskParts.length > 1 && splitFirstOptionalStartPart(maskParts[1]).length > 1) {\n                        generateMask(maskPrefix + masks[0] + markOptional(masks[1]), maskParts[1], metadata);\n                        generateMask(maskPrefix + masks[0], maskParts[1], metadata);\n                    }\n                }\n                else {\n                    newMask = maskPrefix + maskParts;\n                    if ($.inArray(newMask, genmasks) == -1 && newMask != \"\") {\n                        genmasks.push(newMask);\n                        maskTemplate = getMaskTemplate(newMask);\n                        ms.push({\n                            \"mask\": newMask,\n                            \"_buffer\": maskTemplate[\"mask\"],\n                            \"buffer\": maskTemplate[\"mask\"].slice(),\n                            \"tests\": getTestingChain(newMask),\n                            \"lastValidPosition\": -1,\n                            \"greedy\": maskTemplate[\"greedy\"],\n                            \"repeat\": maskTemplate[\"repeat\"],\n                            \"metadata\": metadata\n                        });\n                    }\n                }\n\n            }\n\n            if ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\n                opts.mask = opts.mask.call(this, opts);\n            }\n            if ($.isArray(opts.mask)) {\n                $.each(opts.mask, function (ndx, msk) {\n                    if (msk[\"mask\"] != undefined) {\n                        generateMask(\"\", msk[\"mask\"].toString(), msk);\n                    } else\n                        generateMask(\"\", msk.toString());\n                });\n            } else generateMask(\"\", opts.mask.toString());\n\n            return opts.greedy ? ms : ms.sort(function (a, b) { return a[\"mask\"].length - b[\"mask\"].length; });\n        }\n\n        var msie10 = navigator.userAgent.match(new RegExp(\"msie 10\", \"i\")) !== null,\n            iphone = navigator.userAgent.match(new RegExp(\"iphone\", \"i\")) !== null,\n            android = navigator.userAgent.match(new RegExp(\"android.*safari.*\", \"i\")) !== null,\n            androidchrome = navigator.userAgent.match(new RegExp(\"android.*chrome.*\", \"i\")) !== null,\n            pasteEvent = isInputEventSupported('paste') ? 'paste' : isInputEventSupported('input') ? 'input' : \"propertychange\";\n\n\n        //masking scope\n        //actionObj definition see below\n        function maskScope(masksets, activeMasksetIndex, opts, actionObj) {\n            var isRTL = false,\n                valueOnFocus = getActiveBuffer().join(''),\n                $el, chromeValueOnInput,\n                skipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\n                skipInputEvent = false, //skip when triggered from within inputmask\n                ignorable = false;\n\n\n            //maskset helperfunctions\n\n            function getActiveMaskSet() {\n                return masksets[activeMasksetIndex];\n            }\n\n            function getActiveTests() {\n                return getActiveMaskSet()['tests'];\n            }\n\n            function getActiveBufferTemplate() {\n                return getActiveMaskSet()['_buffer'];\n            }\n\n            function getActiveBuffer() {\n                return getActiveMaskSet()['buffer'];\n            }\n\n            function isValid(pos, c, strict) { //strict true ~ no correction or autofill\n                strict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions \n\n                function _isValid(position, activeMaskset, c, strict) {\n                    var testPos = determineTestPosition(position), loopend = c ? 1 : 0, chrs = '', buffer = activeMaskset[\"buffer\"];\n                    for (var i = activeMaskset['tests'][testPos].cardinality; i > loopend; i--) {\n                        chrs += getBufferElement(buffer, testPos - (i - 1));\n                    }\n\n                    if (c) {\n                        chrs += c;\n                    }\n\n                    //return is false or a json object => { pos: ??, c: ??} or true\n                    return activeMaskset['tests'][testPos].fn != null ?\n                        activeMaskset['tests'][testPos].fn.test(chrs, buffer, position, strict, opts)\n                        : (c == getBufferElement(activeMaskset['_buffer'], position, true) || c == opts.skipOptionalPartCharacter) ?\n                            { \"refresh\": true, c: getBufferElement(activeMaskset['_buffer'], position, true), pos: position }\n                            : false;\n                }\n\n                function PostProcessResults(maskForwards, results) {\n                    var hasValidActual = false;\n                    $.each(results, function (ndx, rslt) {\n                        hasValidActual = $.inArray(rslt[\"activeMasksetIndex\"], maskForwards) == -1 && rslt[\"result\"] !== false;\n                        if (hasValidActual) return false;\n                    });\n                    if (hasValidActual) { //strip maskforwards\n                        results = $.map(results, function (rslt, ndx) {\n                            if ($.inArray(rslt[\"activeMasksetIndex\"], maskForwards) == -1) {\n                                return rslt;\n                            } else {\n                                masksets[rslt[\"activeMasksetIndex\"]][\"lastValidPosition\"] = actualLVP;\n                            }\n                        });\n                    } else { //keep maskforwards with the least forward\n                        var lowestPos = -1, lowestIndex = -1, rsltValid;\n                        $.each(results, function (ndx, rslt) {\n                            if ($.inArray(rslt[\"activeMasksetIndex\"], maskForwards) != -1 && rslt[\"result\"] !== false & (lowestPos == -1 || lowestPos > rslt[\"result\"][\"pos\"])) {\n                                lowestPos = rslt[\"result\"][\"pos\"];\n                                lowestIndex = rslt[\"activeMasksetIndex\"];\n                            }\n                        });\n                        results = $.map(results, function (rslt, ndx) {\n                            if ($.inArray(rslt[\"activeMasksetIndex\"], maskForwards) != -1) {\n                                if (rslt[\"result\"][\"pos\"] == lowestPos) {\n                                    return rslt;\n                                } else if (rslt[\"result\"] !== false) {\n                                    for (var i = pos; i < lowestPos; i++) {\n                                        rsltValid = _isValid(i, masksets[rslt[\"activeMasksetIndex\"]], masksets[lowestIndex][\"buffer\"][i], true);\n                                        if (rsltValid === false) {\n                                            masksets[rslt[\"activeMasksetIndex\"]][\"lastValidPosition\"] = lowestPos - 1;\n                                            break;\n                                        } else {\n                                            setBufferElement(masksets[rslt[\"activeMasksetIndex\"]][\"buffer\"], i, masksets[lowestIndex][\"buffer\"][i], true);\n                                            masksets[rslt[\"activeMasksetIndex\"]][\"lastValidPosition\"] = i;\n                                        }\n                                    }\n                                    //also check check for the lowestpos with the new input\n                                    rsltValid = _isValid(lowestPos, masksets[rslt[\"activeMasksetIndex\"]], c, true);\n                                    if (rsltValid !== false) {\n                                        setBufferElement(masksets[rslt[\"activeMasksetIndex\"]][\"buffer\"], lowestPos, c, true);\n                                        masksets[rslt[\"activeMasksetIndex\"]][\"lastValidPosition\"] = lowestPos;\n                                    }\n                                    //console.log(\"ndx \" + rslt[\"activeMasksetIndex\"] + \" validate \" + masksets[rslt[\"activeMasksetIndex\"]][\"buffer\"].join('') + \" lv \" + masksets[rslt[\"activeMasksetIndex\"]]['lastValidPosition']);\n                                    return rslt;\n                                }\n                            }\n                        });\n                    }\n                    return results;\n                }\n\n                if (strict) {\n                    var result = _isValid(pos, getActiveMaskSet(), c, strict); //only check validity in current mask when validating strict\n                    if (result === true) {\n                        result = { \"pos\": pos }; //always take a possible corrected maskposition into account\n                    }\n                    return result;\n                }\n\n                var results = [], result = false, currentActiveMasksetIndex = activeMasksetIndex,\n                    actualBuffer = getActiveBuffer().slice(), actualLVP = getActiveMaskSet()[\"lastValidPosition\"],\n                    actualPrevious = seekPrevious(pos),\n                    maskForwards = [];\n                $.each(masksets, function (index, value) {\n                    if (typeof (value) == \"object\") {\n                        activeMasksetIndex = index;\n\n                        var maskPos = pos;\n                        var lvp = getActiveMaskSet()['lastValidPosition'],\n                            rsltValid;\n                        if (lvp == actualLVP) {\n                            if ((maskPos - actualLVP) > 1) {\n                                for (var i = lvp == -1 ? 0 : lvp; i < maskPos; i++) {\n                                    rsltValid = _isValid(i, getActiveMaskSet(), actualBuffer[i], true);\n                                    if (rsltValid === false) {\n                                        break;\n                                    } else {\n                                        setBufferElement(getActiveBuffer(), i, actualBuffer[i], true);\n                                        if (rsltValid === true) {\n                                            rsltValid = { \"pos\": i }; //always take a possible corrected maskposition into account\n                                        }\n                                        var newValidPosition = rsltValid.pos || i;\n                                        if (getActiveMaskSet()['lastValidPosition'] < newValidPosition)\n                                            getActiveMaskSet()['lastValidPosition'] = newValidPosition; //set new position from isValid\n                                    }\n                                }\n                            }\n                            //does the input match on a further position?\n                            if (!isMask(maskPos) && !_isValid(maskPos, getActiveMaskSet(), c, strict)) {\n                                var maxForward = seekNext(maskPos) - maskPos;\n                                for (var fw = 0; fw < maxForward; fw++) {\n                                    if (_isValid(++maskPos, getActiveMaskSet(), c, strict) !== false)\n                                        break;\n                                }\n                                maskForwards.push(activeMasksetIndex);\n                                //console.log('maskforward ' + activeMasksetIndex + \" pos \" + pos + \" maskPos \" + maskPos);\n                            }\n                        }\n\n                        if (getActiveMaskSet()['lastValidPosition'] >= actualLVP || activeMasksetIndex == currentActiveMasksetIndex) {\n                            if (maskPos >= 0 && maskPos < getMaskLength()) {\n                                result = _isValid(maskPos, getActiveMaskSet(), c, strict);\n                                if (result !== false) {\n                                    if (result === true) {\n                                        result = { \"pos\": maskPos }; //always take a possible corrected maskposition into account\n                                    }\n                                    var newValidPosition = result.pos || maskPos;\n                                    if (getActiveMaskSet()['lastValidPosition'] < newValidPosition)\n                                        getActiveMaskSet()['lastValidPosition'] = newValidPosition; //set new position from isValid\n                                }\n                                //console.log(\"pos \" + pos + \" ndx \" + activeMasksetIndex + \" validate \" + getActiveBuffer().join('') + \" lv \" + getActiveMaskSet()['lastValidPosition']);\n                                results.push({ \"activeMasksetIndex\": index, \"result\": result });\n                            }\n                        }\n                    }\n                });\n                activeMasksetIndex = currentActiveMasksetIndex; //reset activeMasksetIndex\n\n                return PostProcessResults(maskForwards, results); //return results of the multiple mask validations\n            }\n\n            function determineActiveMasksetIndex() {\n                var currentMasksetIndex = activeMasksetIndex,\n                    highestValid = { \"activeMasksetIndex\": 0, \"lastValidPosition\": -1, \"next\": -1 };\n                $.each(masksets, function (index, value) {\n                    if (typeof (value) == \"object\") {\n                        activeMasksetIndex = index;\n                        if (getActiveMaskSet()['lastValidPosition'] > highestValid['lastValidPosition']) {\n                            highestValid[\"activeMasksetIndex\"] = index;\n                            highestValid[\"lastValidPosition\"] = getActiveMaskSet()['lastValidPosition'];\n                            highestValid[\"next\"] = seekNext(getActiveMaskSet()['lastValidPosition']);\n                        } else if (getActiveMaskSet()['lastValidPosition'] == highestValid['lastValidPosition'] &&\n                            (highestValid['next'] == -1 || highestValid['next'] > seekNext(getActiveMaskSet()['lastValidPosition']))) {\n                            highestValid[\"activeMasksetIndex\"] = index;\n                            highestValid[\"lastValidPosition\"] = getActiveMaskSet()['lastValidPosition'];\n                            highestValid[\"next\"] = seekNext(getActiveMaskSet()['lastValidPosition']);\n                        }\n                    }\n                });\n\n                activeMasksetIndex = highestValid[\"lastValidPosition\"] != -1 && masksets[currentMasksetIndex][\"lastValidPosition\"] == highestValid[\"lastValidPosition\"] ? currentMasksetIndex : highestValid[\"activeMasksetIndex\"];\n                if (currentMasksetIndex != activeMasksetIndex) {\n                    clearBuffer(getActiveBuffer(), seekNext(highestValid[\"lastValidPosition\"]), getMaskLength());\n                    getActiveMaskSet()[\"writeOutBuffer\"] = true;\n                }\n                $el.data('_inputmask')['activeMasksetIndex'] = activeMasksetIndex; //store the activeMasksetIndex\n            }\n\n            function isMask(pos) {\n                var testPos = determineTestPosition(pos);\n                var test = getActiveTests()[testPos];\n\n                return test != undefined ? test.fn : false;\n            }\n\n            function determineTestPosition(pos) {\n                return pos % getActiveTests().length;\n            }\n\n            function getMaskLength() {\n                return opts.getMaskLength(getActiveBufferTemplate(), getActiveMaskSet()['greedy'], getActiveMaskSet()['repeat'], getActiveBuffer(), opts);\n            }\n\n            //pos: from position\n\n            function seekNext(pos) {\n                var maskL = getMaskLength();\n                if (pos >= maskL) return maskL;\n                var position = pos;\n                while (++position < maskL && !isMask(position)) {\n                }\n                return position;\n            }\n\n            //pos: from position\n\n            function seekPrevious(pos) {\n                var position = pos;\n                if (position <= 0) return 0;\n\n                while (--position > 0 && !isMask(position)) {\n                }\n                return position;\n            }\n\n            function setBufferElement(buffer, position, element, autoPrepare) {\n                if (autoPrepare) position = prepareBuffer(buffer, position);\n\n                var test = getActiveTests()[determineTestPosition(position)];\n                var elem = element;\n                if (elem != undefined && test != undefined) {\n                    switch (test.casing) {\n                        case \"upper\":\n                            elem = element.toUpperCase();\n                            break;\n                        case \"lower\":\n                            elem = element.toLowerCase();\n                            break;\n                    }\n                }\n\n                buffer[position] = elem;\n            }\n\n            function getBufferElement(buffer, position, autoPrepare) {\n                if (autoPrepare) position = prepareBuffer(buffer, position);\n                return buffer[position];\n            }\n\n            //needed to handle the non-greedy mask repetitions\n\n            function prepareBuffer(buffer, position) {\n                var j;\n                while (buffer[position] == undefined && buffer.length < getMaskLength()) {\n                    j = 0;\n                    while (getActiveBufferTemplate()[j] !== undefined) { //add a new buffer\n                        buffer.push(getActiveBufferTemplate()[j++]);\n                    }\n                }\n\n                return position;\n            }\n\n            function writeBuffer(input, buffer, caretPos) {\n                input._valueSet(buffer.join(''));\n                if (caretPos != undefined) {\n                    caret(input, caretPos);\n                }\n            }\n\n            function clearBuffer(buffer, start, end, stripNomasks) {\n                for (var i = start, maskL = getMaskLength() ; i < end && i < maskL; i++) {\n                    if (stripNomasks === true) {\n                        if (!isMask(i))\n                            setBufferElement(buffer, i, \"\");\n                    } else\n                        setBufferElement(buffer, i, getBufferElement(getActiveBufferTemplate().slice(), i, true));\n                }\n            }\n\n            function setReTargetPlaceHolder(buffer, pos) {\n                var testPos = determineTestPosition(pos);\n                setBufferElement(buffer, pos, getBufferElement(getActiveBufferTemplate(), testPos));\n            }\n\n            function getPlaceHolder(pos) {\n                return opts.placeholder.charAt(pos % opts.placeholder.length);\n            }\n\n            function checkVal(input, writeOut, strict, nptvl, intelliCheck) {\n                var inputValue = nptvl != undefined ? nptvl.slice() : truncateInput(input._valueGet()).split('');\n\n                $.each(masksets, function (ndx, ms) {\n                    if (typeof (ms) == \"object\") {\n                        ms[\"buffer\"] = ms[\"_buffer\"].slice();\n                        ms[\"lastValidPosition\"] = -1;\n                        ms[\"p\"] = -1;\n                    }\n                });\n                if (strict !== true) activeMasksetIndex = 0;\n                if (writeOut) input._valueSet(\"\"); //initial clear\n                var ml = getMaskLength();\n                $.each(inputValue, function (ndx, charCode) {\n                    if (intelliCheck === true) {\n                        var p = getActiveMaskSet()[\"p\"], lvp = p == -1 ? p : seekPrevious(p),\n                            pos = lvp == -1 ? ndx : seekNext(lvp);\n                        if ($.inArray(charCode, getActiveBufferTemplate().slice(lvp + 1, pos)) == -1) {\n                            keypressEvent.call(input, undefined, true, charCode.charCodeAt(0), writeOut, strict, ndx);\n                        }\n                    } else {\n                        keypressEvent.call(input, undefined, true, charCode.charCodeAt(0), writeOut, strict, ndx);\n                    }\n                });\n\n                if (strict === true && getActiveMaskSet()[\"p\"] != -1) {\n                    getActiveMaskSet()[\"lastValidPosition\"] = seekPrevious(getActiveMaskSet()[\"p\"]);\n                }\n            }\n\n            function escapeRegex(str) {\n                return $.inputmask.escapeRegex.call(this, str);\n            }\n\n            function truncateInput(inputValue) {\n                return inputValue.replace(new RegExp(\"(\" + escapeRegex(getActiveBufferTemplate().join('')) + \")*$\"), \"\");\n            }\n\n            function clearOptionalTail(input) {\n                var buffer = getActiveBuffer(), tmpBuffer = buffer.slice(), testPos, pos;\n                for (var pos = tmpBuffer.length - 1; pos >= 0; pos--) {\n                    var testPos = determineTestPosition(pos);\n                    if (getActiveTests()[testPos].optionality) {\n                        if (!isMask(pos) || !isValid(pos, buffer[pos], true))\n                            tmpBuffer.pop();\n                        else break;\n                    } else break;\n                }\n                writeBuffer(input, tmpBuffer);\n            }\n\n            function unmaskedvalue($input, skipDatepickerCheck) {\n                if (getActiveTests() && (skipDatepickerCheck === true || !$input.hasClass('hasDatepicker'))) {\n                    //checkVal(input, false, true);\n                    var umValue = $.map(getActiveBuffer(), function (element, index) {\n                        return isMask(index) && isValid(index, element, true) ? element : null;\n                    });\n                    var unmaskedValue = (isRTL ? umValue.reverse() : umValue).join('');\n                    return opts.onUnMask != undefined ? opts.onUnMask.call(this, getActiveBuffer().join(''), unmaskedValue) : unmaskedValue;\n                } else {\n                    return $input[0]._valueGet();\n                }\n            }\n\n            function TranslatePosition(pos) {\n                if (isRTL && typeof pos == 'number' && (!opts.greedy || opts.placeholder != \"\")) {\n                    var bffrLght = getActiveBuffer().length;\n                    pos = bffrLght - pos;\n                }\n                return pos;\n            }\n\n            function caret(input, begin, end) {\n                var npt = input.jquery && input.length > 0 ? input[0] : input, range;\n                if (typeof begin == 'number') {\n                    begin = TranslatePosition(begin);\n                    end = TranslatePosition(end);\n                    if (!$(input).is(':visible')) {\n                        return;\n                    }\n                    end = (typeof end == 'number') ? end : begin;\n                    npt.scrollLeft = npt.scrollWidth;\n                    if (opts.insertMode == false && begin == end) end++; //set visualization for insert/overwrite mode\n                    if (npt.setSelectionRange) {\n                        npt.selectionStart = begin;\n                        npt.selectionEnd = android ? begin : end;\n\n                    } else if (npt.createTextRange) {\n                        range = npt.createTextRange();\n                        range.collapse(true);\n                        range.moveEnd('character', end);\n                        range.moveStart('character', begin);\n                        range.select();\n                    }\n                } else {\n                    if (!$(input).is(':visible')) {\n                        return { \"begin\": 0, \"end\": 0 };\n                    }\n                    if (npt.setSelectionRange) {\n                        begin = npt.selectionStart;\n                        end = npt.selectionEnd;\n                    } else if (document.selection && document.selection.createRange) {\n                        range = document.selection.createRange();\n                        begin = 0 - range.duplicate().moveStart('character', -100000);\n                        end = begin + range.text.length;\n                    }\n                    begin = TranslatePosition(begin);\n                    end = TranslatePosition(end);\n                    return { \"begin\": begin, \"end\": end };\n                }\n            }\n\n            function isComplete(buffer) { //return true / false / undefined (repeat *)\n                if (opts.repeat == \"*\") return undefined;\n                var complete = false, highestValidPosition = 0, currentActiveMasksetIndex = activeMasksetIndex;\n                $.each(masksets, function (ndx, ms) {\n                    if (typeof (ms) == \"object\") {\n                        activeMasksetIndex = ndx;\n                        var aml = seekPrevious(getMaskLength());\n                        if (ms[\"lastValidPosition\"] >= highestValidPosition && ms[\"lastValidPosition\"] == aml) {\n                            var msComplete = true;\n                            for (var i = 0; i <= aml; i++) {\n                                var mask = isMask(i), testPos = determineTestPosition(i);\n                                if ((mask && (buffer[i] == undefined || buffer[i] == getPlaceHolder(i))) || (!mask && buffer[i] != getActiveBufferTemplate()[testPos])) {\n                                    msComplete = false;\n                                    break;\n                                }\n                            }\n                            complete = complete || msComplete;\n                            if (complete) //break loop\n                                return false;\n                        }\n                        highestValidPosition = ms[\"lastValidPosition\"];\n                    }\n                });\n                activeMasksetIndex = currentActiveMasksetIndex; //reset activeMaskset\n                return complete;\n            }\n\n            function isSelection(begin, end) {\n                return isRTL ? (begin - end) > 1 || ((begin - end) == 1 && opts.insertMode) :\n                    (end - begin) > 1 || ((end - begin) == 1 && opts.insertMode);\n            }\n\n\n            //private functions\n            function installEventRuler(npt) {\n                var events = $._data(npt).events;\n\n                $.each(events, function (eventType, eventHandlers) {\n                    $.each(eventHandlers, function (ndx, eventHandler) {\n                        if (eventHandler.namespace == \"inputmask\") {\n                            if (eventHandler.type != \"setvalue\") {\n                                var handler = eventHandler.handler;\n                                eventHandler.handler = function (e) {\n                                    if (this.readOnly || this.disabled)\n                                        e.preventDefault;\n                                    else\n                                        return handler.apply(this, arguments);\n                                };\n                            }\n                        }\n                    });\n                });\n            }\n\n            function patchValueProperty(npt) {\n                var valueProperty;\n                if (Object.getOwnPropertyDescriptor)\n                    valueProperty = Object.getOwnPropertyDescriptor(npt, \"value\");\n                if (valueProperty && valueProperty.get) {\n                    if (!npt._valueGet) {\n                        var valueGet = valueProperty.get;\n                        var valueSet = valueProperty.set;\n                        npt._valueGet = function () {\n                            return isRTL ? valueGet.call(this).split('').reverse().join('') : valueGet.call(this);\n                        };\n                        npt._valueSet = function (value) {\n                            valueSet.call(this, isRTL ? value.split('').reverse().join('') : value);\n                        };\n\n                        Object.defineProperty(npt, \"value\", {\n                            get: function () {\n                                var $self = $(this), inputData = $(this).data('_inputmask'), masksets = inputData['masksets'],\n                                    activeMasksetIndex = inputData['activeMasksetIndex'];\n                                return inputData && inputData['opts'].autoUnmask ? $self.inputmask('unmaskedvalue') : valueGet.call(this) != masksets[activeMasksetIndex]['_buffer'].join('') ? valueGet.call(this) : '';\n                            },\n                            set: function (value) {\n                                valueSet.call(this, value);\n                                $(this).triggerHandler('setvalue.inputmask');\n                            }\n                        });\n                    }\n                } else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\n                    if (!npt._valueGet) {\n                        var valueGet = npt.__lookupGetter__(\"value\");\n                        var valueSet = npt.__lookupSetter__(\"value\");\n                        npt._valueGet = function () {\n                            return isRTL ? valueGet.call(this).split('').reverse().join('') : valueGet.call(this);\n                        };\n                        npt._valueSet = function (value) {\n                            valueSet.call(this, isRTL ? value.split('').reverse().join('') : value);\n                        };\n\n                        npt.__defineGetter__(\"value\", function () {\n                            var $self = $(this), inputData = $(this).data('_inputmask'), masksets = inputData['masksets'],\n                                activeMasksetIndex = inputData['activeMasksetIndex'];\n                            return inputData && inputData['opts'].autoUnmask ? $self.inputmask('unmaskedvalue') : valueGet.call(this) != masksets[activeMasksetIndex]['_buffer'].join('') ? valueGet.call(this) : '';\n                        });\n                        npt.__defineSetter__(\"value\", function (value) {\n                            valueSet.call(this, value);\n                            $(this).triggerHandler('setvalue.inputmask');\n                        });\n                    }\n                } else {\n                    if (!npt._valueGet) {\n                        npt._valueGet = function () { return isRTL ? this.value.split('').reverse().join('') : this.value; };\n                        npt._valueSet = function (value) { this.value = isRTL ? value.split('').reverse().join('') : value; };\n                    }\n                    if ($.valHooks.text == undefined || $.valHooks.text.inputmaskpatch != true) {\n                        var valueGet = $.valHooks.text && $.valHooks.text.get ? $.valHooks.text.get : function (elem) { return elem.value; };\n                        var valueSet = $.valHooks.text && $.valHooks.text.set ? $.valHooks.text.set : function (elem, value) {\n                            elem.value = value;\n                            return elem;\n                        };\n\n                        jQuery.extend($.valHooks, {\n                            text: {\n                                get: function (elem) {\n                                    var $elem = $(elem);\n                                    if ($elem.data('_inputmask')) {\n                                        if ($elem.data('_inputmask')['opts'].autoUnmask)\n                                            return $elem.inputmask('unmaskedvalue');\n                                        else {\n                                            var result = valueGet(elem),\n                                                inputData = $elem.data('_inputmask'), masksets = inputData['masksets'],\n                                                activeMasksetIndex = inputData['activeMasksetIndex'];\n                                            return result != masksets[activeMasksetIndex]['_buffer'].join('') ? result : '';\n                                        }\n                                    } else return valueGet(elem);\n                                },\n                                set: function (elem, value) {\n                                    var $elem = $(elem);\n                                    var result = valueSet(elem, value);\n                                    if ($elem.data('_inputmask')) $elem.triggerHandler('setvalue.inputmask');\n                                    return result;\n                                },\n                                inputmaskpatch: true\n                            }\n                        });\n                    }\n                }\n            }\n\n            //shift chars to left from start to end and put c at end position if defined\n\n            function shiftL(start, end, c, maskJumps) {\n                var buffer = getActiveBuffer();\n                if (maskJumps !== false) //jumping over nonmask position\n                    while (!isMask(start) && start - 1 >= 0) start--;\n                for (var i = start; i < end && i < getMaskLength() ; i++) {\n                    if (isMask(i)) {\n                        setReTargetPlaceHolder(buffer, i);\n                        var j = seekNext(i);\n                        var p = getBufferElement(buffer, j);\n                        if (p != getPlaceHolder(j)) {\n                            if (j < getMaskLength() && isValid(i, p, true) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def) {\n                                setBufferElement(buffer, i, p, true);\n                            } else {\n                                if (isMask(i))\n                                    break;\n                            }\n                        }\n                    } else {\n                        setReTargetPlaceHolder(buffer, i);\n                    }\n                }\n                if (c != undefined)\n                    setBufferElement(buffer, seekPrevious(end), c);\n\n                if (getActiveMaskSet()[\"greedy\"] == false) {\n                    var trbuffer = truncateInput(buffer.join('')).split('');\n                    buffer.length = trbuffer.length;\n                    for (var i = 0, bl = buffer.length; i < bl; i++) {\n                        buffer[i] = trbuffer[i];\n                    }\n                    if (buffer.length == 0) getActiveMaskSet()[\"buffer\"] = getActiveBufferTemplate().slice();\n                }\n                return start; //return the used start position\n            }\n\n            function shiftR(start, end, c) {\n                var buffer = getActiveBuffer();\n                if (getBufferElement(buffer, start, true) != getPlaceHolder(start)) {\n                    for (var i = seekPrevious(end) ; i > start && i >= 0; i--) {\n                        if (isMask(i)) {\n                            var j = seekPrevious(i);\n                            var t = getBufferElement(buffer, j);\n                            if (t != getPlaceHolder(j)) {\n                                if (isValid(j, t, true) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def) {\n                                    setBufferElement(buffer, i, t, true);\n                                    setReTargetPlaceHolder(buffer, j);\n                                } //else break;\n                            }\n                        } else\n                            setReTargetPlaceHolder(buffer, i);\n                    }\n                }\n                if (c != undefined && getBufferElement(buffer, start) == getPlaceHolder(start))\n                    setBufferElement(buffer, start, c);\n                var lengthBefore = buffer.length;\n                if (getActiveMaskSet()[\"greedy\"] == false) {\n                    var trbuffer = truncateInput(buffer.join('')).split('');\n                    buffer.length = trbuffer.length;\n                    for (var i = 0, bl = buffer.length; i < bl; i++) {\n                        buffer[i] = trbuffer[i];\n                    }\n                    if (buffer.length == 0) getActiveMaskSet()[\"buffer\"] = getActiveBufferTemplate().slice();\n                }\n                return end - (lengthBefore - buffer.length); //return new start position\n            }\n\n            function HandleRemove(input, k, pos) {\n                if (opts.numericInput || isRTL) {\n                    switch (k) {\n                        case opts.keyCode.BACKSPACE:\n                            k = opts.keyCode.DELETE;\n                            break;\n                        case opts.keyCode.DELETE:\n                            k = opts.keyCode.BACKSPACE;\n                            break;\n                    }\n                    if (isRTL) {\n                        var pend = pos.end;\n                        pos.end = pos.begin;\n                        pos.begin = pend;\n                    }\n                }\n\n                var isSelection = true;\n                if (pos.begin == pos.end) {\n                    var posBegin = k == opts.keyCode.BACKSPACE ? pos.begin - 1 : pos.begin;\n                    if (opts.isNumeric && opts.radixPoint != \"\" && getActiveBuffer()[posBegin] == opts.radixPoint) {\n                        pos.begin = (getActiveBuffer().length - 1 == posBegin) /* radixPoint is latest? delete it */ ? pos.begin : k == opts.keyCode.BACKSPACE ? posBegin : seekNext(posBegin);\n                        pos.end = pos.begin;\n                    }\n                    isSelection = false;\n                    if (k == opts.keyCode.BACKSPACE)\n                        pos.begin--;\n                    else if (k == opts.keyCode.DELETE)\n                        pos.end++;\n                } else if (pos.end - pos.begin == 1 && !opts.insertMode) {\n                    isSelection = false;\n                    if (k == opts.keyCode.BACKSPACE)\n                        pos.begin--;\n                }\n\n                clearBuffer(getActiveBuffer(), pos.begin, pos.end);\n\n                var ml = getMaskLength();\n                if (opts.greedy == false) {\n                    shiftL(pos.begin, ml, undefined, !isRTL && (k == opts.keyCode.BACKSPACE && !isSelection));\n                } else {\n                    var newpos = pos.begin;\n                    for (var i = pos.begin; i < pos.end; i++) { //seeknext to skip placeholders at start in selection\n                        if (isMask(i) || !isSelection)\n                            newpos = shiftL(pos.begin, ml, undefined, !isRTL && (k == opts.keyCode.BACKSPACE && !isSelection));\n                    }\n                    if (!isSelection) pos.begin = newpos;\n                }\n                var firstMaskPos = seekNext(-1);\n                clearBuffer(getActiveBuffer(), pos.begin, pos.end, true);\n                checkVal(input, false, masksets[1] == undefined || firstMaskPos >= pos.end, getActiveBuffer());\n                if (getActiveMaskSet()['lastValidPosition'] < firstMaskPos) {\n                    getActiveMaskSet()[\"lastValidPosition\"] = -1;\n                    getActiveMaskSet()[\"p\"] = firstMaskPos;\n                } else {\n                    getActiveMaskSet()[\"p\"] = pos.begin;\n                }\n            }\n\n            function keydownEvent(e) {\n                //Safari 5.1.x - modal dialog fires keypress twice workaround\n                skipKeyPressEvent = false;\n                var input = this, $input = $(input), k = e.keyCode, pos = caret(input);\n\n                //backspace, delete, and escape get special treatment\n                if (k == opts.keyCode.BACKSPACE || k == opts.keyCode.DELETE || (iphone && k == 127) || e.ctrlKey && k == 88) { //backspace/delete\n                    e.preventDefault(); //stop default action but allow propagation\n                    if (k == 88) valueOnFocus = getActiveBuffer().join('');\n                    HandleRemove(input, k, pos);\n                    determineActiveMasksetIndex();\n                    writeBuffer(input, getActiveBuffer(), getActiveMaskSet()[\"p\"]);\n                    if (input._valueGet() == getActiveBufferTemplate().join(''))\n                        $input.trigger('cleared');\n\n                    if (opts.showTooltip) { //update tooltip\n                        $input.prop(\"title\", getActiveMaskSet()[\"mask\"]);\n                    }\n                } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\n                    setTimeout(function () {\n                        var caretPos = seekNext(getActiveMaskSet()[\"lastValidPosition\"]);\n                        if (!opts.insertMode && caretPos == getMaskLength() && !e.shiftKey) caretPos--;\n                        caret(input, e.shiftKey ? pos.begin : caretPos, caretPos);\n                    }, 0);\n                } else if ((k == opts.keyCode.HOME && !e.shiftKey) || k == opts.keyCode.PAGE_UP) { //Home or page_up\n                    caret(input, 0, e.shiftKey ? pos.begin : 0);\n                } else if (k == opts.keyCode.ESCAPE || (k == 90 && e.ctrlKey)) { //escape && undo\n                    checkVal(input, true, false, valueOnFocus.split(''));\n                    $input.click();\n                } else if (k == opts.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert\n                    opts.insertMode = !opts.insertMode;\n                    caret(input, !opts.insertMode && pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin);\n                } else if (opts.insertMode == false && !e.shiftKey) {\n                    if (k == opts.keyCode.RIGHT) {\n                        setTimeout(function () {\n                            var caretPos = caret(input);\n                            caret(input, caretPos.begin);\n                        }, 0);\n                    } else if (k == opts.keyCode.LEFT) {\n                        setTimeout(function () {\n                            var caretPos = caret(input);\n                            caret(input, caretPos.begin - 1);\n                        }, 0);\n                    }\n                }\n\n                var currentCaretPos = caret(input);\n                if (opts.onKeyDown.call(this, e, getActiveBuffer(), opts) === true) //extra stuff to execute on keydown\n                    caret(input, currentCaretPos.begin, currentCaretPos.end);\n                ignorable = $.inArray(k, opts.ignorables) != -1;\n            }\n\n\n            function keypressEvent(e, checkval, k, writeOut, strict, ndx) {\n                //Safari 5.1.x - modal dialog fires keypress twice workaround\n                if (k == undefined && skipKeyPressEvent) return false;\n                skipKeyPressEvent = true;\n\n                var input = this, $input = $(input);\n\n                e = e || window.event;\n                var k = checkval ? k : (e.which || e.charCode || e.keyCode);\n\n                if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\n                    return true;\n                } else {\n                    if (k) {\n                        //special treat the decimal separator\n                        if (checkval !== true && k == 46 && e.shiftKey == false && opts.radixPoint == \",\") k = 44;\n\n                        var pos, results, result, c = String.fromCharCode(k);\n                        if (checkval) {\n                            var pcaret = strict ? ndx : getActiveMaskSet()[\"lastValidPosition\"] + 1;\n                            pos = { begin: pcaret, end: pcaret };\n                        } else {\n                            pos = caret(input);\n                        }\n\n                        //should we clear a possible selection??\n                        var isSlctn = isSelection(pos.begin, pos.end), redetermineLVP = false,\n                            initialIndex = activeMasksetIndex;\n                        if (isSlctn) {\n                            activeMasksetIndex = initialIndex;\n                            $.each(masksets, function (ndx, lmnt) { //init undobuffer for recovery when not valid\n                                if (typeof (lmnt) == \"object\") {\n                                    activeMasksetIndex = ndx;\n                                    getActiveMaskSet()[\"undoBuffer\"] = getActiveBuffer().join('');\n                                }\n                            });\n                            HandleRemove(input, opts.keyCode.DELETE, pos);\n                            if (!opts.insertMode) { //preserve some space\n                                $.each(masksets, function (ndx, lmnt) {\n                                    if (typeof (lmnt) == \"object\") {\n                                        activeMasksetIndex = ndx;\n                                        shiftR(pos.begin, getMaskLength());\n                                        getActiveMaskSet()[\"lastValidPosition\"] = seekNext(getActiveMaskSet()[\"lastValidPosition\"]);\n                                    }\n                                });\n                            }\n                            activeMasksetIndex = initialIndex; //restore index\n                        }\n\n                        var radixPosition = getActiveBuffer().join('').indexOf(opts.radixPoint);\n                        if (opts.isNumeric && checkval !== true && radixPosition != -1) {\n                            if (opts.greedy && pos.begin <= radixPosition) {\n                                pos.begin = seekPrevious(pos.begin);\n                                pos.end = pos.begin;\n                            } else if (c == opts.radixPoint) {\n                                pos.begin = radixPosition;\n                                pos.end = pos.begin;\n                            }\n                        }\n\n\n                        var p = pos.begin;\n                        results = isValid(p, c, strict);\n                        if (strict === true) results = [{ \"activeMasksetIndex\": activeMasksetIndex, \"result\": results }];\n                        var minimalForwardPosition = -1;\n                        $.each(results, function (index, result) {\n                            activeMasksetIndex = result[\"activeMasksetIndex\"];\n                            getActiveMaskSet()[\"writeOutBuffer\"] = true;\n                            var np = result[\"result\"];\n                            if (np !== false) {\n                                var refresh = false, buffer = getActiveBuffer();\n                                if (np !== true) {\n                                    refresh = np[\"refresh\"]; //only rewrite buffer from isValid\n                                    p = np.pos != undefined ? np.pos : p; //set new position from isValid\n                                    c = np.c != undefined ? np.c : c; //set new char from isValid\n                                }\n                                if (refresh !== true) {\n                                    if (opts.insertMode == true) {\n                                        var lastUnmaskedPosition = getMaskLength();\n                                        var bfrClone = buffer.slice();\n                                        while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) && lastUnmaskedPosition >= p) {\n                                            lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(lastUnmaskedPosition);\n                                        }\n                                        if (lastUnmaskedPosition >= p) {\n                                            shiftR(p, getMaskLength(), c);\n                                            //shift the lvp if needed\n                                            var lvp = getActiveMaskSet()[\"lastValidPosition\"], nlvp = seekNext(lvp);\n                                            if (nlvp != getMaskLength() && lvp >= p && (getBufferElement(getActiveBuffer(), nlvp, true) != getPlaceHolder(nlvp))) {\n                                                getActiveMaskSet()[\"lastValidPosition\"] = nlvp;\n                                            }\n                                        } else getActiveMaskSet()[\"writeOutBuffer\"] = false;\n                                    } else setBufferElement(buffer, p, c, true);\n                                    if (minimalForwardPosition == -1 || minimalForwardPosition > seekNext(p)) {\n                                        minimalForwardPosition = seekNext(p);\n                                    }\n                                } else if (!strict) {\n                                    var nextPos = p < getMaskLength() ? p + 1 : p;\n                                    if (minimalForwardPosition == -1 || minimalForwardPosition > nextPos) {\n                                        minimalForwardPosition = nextPos;\n                                    }\n                                }\n                                if (minimalForwardPosition > getActiveMaskSet()[\"p\"])\n                                    getActiveMaskSet()[\"p\"] = minimalForwardPosition; //needed for checkval strict \n                            }\n                        });\n\n                        if (strict !== true) {\n                            activeMasksetIndex = initialIndex;\n                            determineActiveMasksetIndex();\n                        }\n                        if (writeOut !== false) {\n                            $.each(results, function (ndx, rslt) {\n                                if (rslt[\"activeMasksetIndex\"] == activeMasksetIndex) {\n                                    result = rslt;\n                                    return false;\n                                }\n                            });\n                            if (result != undefined) {\n                                var self = this;\n                                setTimeout(function () { opts.onKeyValidation.call(self, result[\"result\"], opts); }, 0);\n                                if (getActiveMaskSet()[\"writeOutBuffer\"] && result[\"result\"] !== false) {\n                                    var buffer = getActiveBuffer();\n\n                                    var newCaretPosition;\n                                    if (checkval) {\n                                        newCaretPosition = undefined;\n                                    } else if (opts.numericInput) {\n                                        if (p > radixPosition) {\n                                            newCaretPosition = seekPrevious(minimalForwardPosition);\n                                        } else if (c == opts.radixPoint) {\n                                            newCaretPosition = minimalForwardPosition - 1;\n                                        } else newCaretPosition = seekPrevious(minimalForwardPosition - 1);\n                                    } else {\n                                        newCaretPosition = minimalForwardPosition;\n                                    }\n\n                                    writeBuffer(input, buffer, newCaretPosition);\n                                    if (checkval !== true) {\n                                        setTimeout(function () { //timeout needed for IE\n                                            if (isComplete(buffer) === true)\n                                                $input.trigger(\"complete\");\n                                            skipInputEvent = true;\n                                            $input.trigger(\"input\");\n                                        }, 0);\n                                    }\n                                } else if (isSlctn) {\n                                    getActiveMaskSet()[\"buffer\"] = getActiveMaskSet()[\"undoBuffer\"].split('');\n                                }\n                            }\n                        }\n\n                        if (opts.showTooltip) { //update tooltip\n                            $input.prop(\"title\", getActiveMaskSet()[\"mask\"]);\n                        }\n\n                        //needed for IE8 and below\n                        if (e) e.preventDefault ? e.preventDefault() : e.returnValue = false;\n                    }\n                }\n            }\n\n            function keyupEvent(e) {\n                var $input = $(this), input = this, k = e.keyCode, buffer = getActiveBuffer();\n\n                if (androidchrome && k == opts.keyCode.BACKSPACE) {\n                    if (chromeValueOnInput == input._valueGet())\n                        keydownEvent.call(this, e);\n                }\n\n                opts.onKeyUp.call(this, e, buffer, opts); //extra stuff to execute on keyup\n                if (k == opts.keyCode.TAB && opts.showMaskOnFocus) {\n                    if ($input.hasClass('focus.inputmask') && input._valueGet().length == 0) {\n                        buffer = getActiveBufferTemplate().slice();\n                        writeBuffer(input, buffer);\n                        caret(input, 0);\n                        valueOnFocus = getActiveBuffer().join('');\n                    } else {\n                        writeBuffer(input, buffer);\n                        if (buffer.join('') == getActiveBufferTemplate().join('') && $.inArray(opts.radixPoint, buffer) != -1) {\n                            caret(input, TranslatePosition(0));\n                            $input.click();\n                        } else\n                            caret(input, TranslatePosition(0), TranslatePosition(getMaskLength()));\n                    }\n                }\n            }\n\n            function inputEvent(e) {\n                if (skipInputEvent === true) {\n                    skipInputEvent = false;\n                    return true;\n                }\n                var input = this, $input = $(input);\n\n                chromeValueOnInput = getActiveBuffer().join('');\n                checkVal(input, false, false);\n                writeBuffer(input, getActiveBuffer());\n                if (isComplete(getActiveBuffer()) === true)\n                    $input.trigger(\"complete\");\n                $input.click();\n            }\n\n            function mask(el) {\n                $el = $(el);\n                if ($el.is(\":input\")) {\n                    //store tests & original buffer in the input element - used to get the unmasked value\n                    $el.data('_inputmask', {\n                        'masksets': masksets,\n                        'activeMasksetIndex': activeMasksetIndex,\n                        'opts': opts,\n                        'isRTL': false\n                    });\n\n                    //show tooltip\n                    if (opts.showTooltip) {\n                        $el.prop(\"title\", getActiveMaskSet()[\"mask\"]);\n                    }\n\n                    //correct greedy setting if needed\n                    getActiveMaskSet()['greedy'] = getActiveMaskSet()['greedy'] ? getActiveMaskSet()['greedy'] : getActiveMaskSet()['repeat'] == 0;\n\n                    //handle maxlength attribute\n                    if ($el.attr(\"maxLength\") != null) //only when the attribute is set\n                    {\n                        var maxLength = $el.prop('maxLength');\n                        if (maxLength > -1) { //handle *-repeat\n                            $.each(masksets, function (ndx, ms) {\n                                if (typeof (ms) == \"object\") {\n                                    if (ms[\"repeat\"] == \"*\") {\n                                        ms[\"repeat\"] = maxLength;\n                                    }\n                                }\n                            });\n                        }\n                        if (getMaskLength() >= maxLength && maxLength > -1) { //FF sets no defined max length to -1 \n                            if (maxLength < getActiveBufferTemplate().length) getActiveBufferTemplate().length = maxLength;\n                            if (getActiveMaskSet()['greedy'] == false) {\n                                getActiveMaskSet()['repeat'] = Math.round(maxLength / getActiveBufferTemplate().length);\n                            }\n                            $el.prop('maxLength', getMaskLength() * 2);\n                        }\n                    }\n\n                    patchValueProperty(el);\n\n                    if (opts.numericInput) opts.isNumeric = opts.numericInput;\n                    if (el.dir == \"rtl\" || (opts.numericInput && opts.rightAlignNumerics) || (opts.isNumeric && opts.rightAlignNumerics))\n                        $el.css(\"text-align\", \"right\");\n\n                    if (el.dir == \"rtl\" || opts.numericInput) {\n                        el.dir = \"ltr\";\n                        $el.removeAttr(\"dir\");\n                        var inputData = $el.data('_inputmask');\n                        inputData['isRTL'] = true;\n                        $el.data('_inputmask', inputData);\n                        isRTL = true;\n                    }\n\n                    //unbind all events - to make sure that no other mask will interfere when re-masking\n                    $el.unbind(\".inputmask\");\n                    $el.removeClass('focus.inputmask');\n                    //bind events\n                    $el.closest('form').bind(\"submit\", function () { //trigger change on submit if any\n                        if (valueOnFocus != getActiveBuffer().join('')) {\n                            $el.change();\n                        }\n                    }).bind('reset', function () {\n                        setTimeout(function () {\n                            $el.trigger(\"setvalue\");\n                        }, 0);\n                    });\n                    $el.bind(\"mouseenter.inputmask\", function () {\n                        var $input = $(this), input = this;\n                        if (!$input.hasClass('focus.inputmask') && opts.showMaskOnHover) {\n                            if (input._valueGet() != getActiveBuffer().join('')) {\n                                writeBuffer(input, getActiveBuffer());\n                            }\n                        }\n                    }).bind(\"blur.inputmask\", function () {\n                        var $input = $(this), input = this, nptValue = input._valueGet(), buffer = getActiveBuffer();\n                        $input.removeClass('focus.inputmask');\n                        if (valueOnFocus != getActiveBuffer().join('')) {\n                            $input.change();\n                        }\n                        if (opts.clearMaskOnLostFocus && nptValue != '') {\n                            if (nptValue == getActiveBufferTemplate().join(''))\n                                input._valueSet('');\n                            else { //clearout optional tail of the mask\n                                clearOptionalTail(input);\n                            }\n                        }\n                        if (isComplete(buffer) === false) {\n                            $input.trigger(\"incomplete\");\n                            if (opts.clearIncomplete) {\n                                $.each(masksets, function (ndx, ms) {\n                                    if (typeof (ms) == \"object\") {\n                                        ms[\"buffer\"] = ms[\"_buffer\"].slice();\n                                        ms[\"lastValidPosition\"] = -1;\n                                    }\n                                });\n                                activeMasksetIndex = 0;\n                                if (opts.clearMaskOnLostFocus)\n                                    input._valueSet('');\n                                else {\n                                    buffer = getActiveBufferTemplate().slice();\n                                    writeBuffer(input, buffer);\n                                }\n                            }\n                        }\n                    }).bind(\"focus.inputmask\", function () {\n                        var $input = $(this), input = this, nptValue = input._valueGet();\n                        if (opts.showMaskOnFocus && !$input.hasClass('focus.inputmask') && (!opts.showMaskOnHover || (opts.showMaskOnHover && nptValue == ''))) {\n                            if (input._valueGet() != getActiveBuffer().join('')) {\n                                writeBuffer(input, getActiveBuffer(), seekNext(getActiveMaskSet()[\"lastValidPosition\"]));\n                            }\n                        }\n                        $input.addClass('focus.inputmask');\n                        valueOnFocus = getActiveBuffer().join('');\n                    }).bind(\"mouseleave.inputmask\", function () {\n                        var $input = $(this), input = this;\n                        if (opts.clearMaskOnLostFocus) {\n                            if (!$input.hasClass('focus.inputmask') && input._valueGet() != $input.attr(\"placeholder\")) {\n                                if (input._valueGet() == getActiveBufferTemplate().join('') || input._valueGet() == '')\n                                    input._valueSet('');\n                                else { //clearout optional tail of the mask\n                                    clearOptionalTail(input);\n                                }\n                            }\n                        }\n                    }).bind(\"click.inputmask\", function () {\n                        var input = this;\n                        setTimeout(function () {\n                            var selectedCaret = caret(input), buffer = getActiveBuffer();\n                            if (selectedCaret.begin == selectedCaret.end) {\n                                var clickPosition = isRTL ? TranslatePosition(selectedCaret.begin) : selectedCaret.begin,\n                                    lvp = getActiveMaskSet()[\"lastValidPosition\"],\n                                    lastPosition;\n                                if (opts.isNumeric) {\n                                    lastPosition = opts.skipRadixDance === false && opts.radixPoint != \"\" && $.inArray(opts.radixPoint, buffer) != -1 ?\n                                        (opts.numericInput ? seekNext($.inArray(opts.radixPoint, buffer)) : $.inArray(opts.radixPoint, buffer)) :\n                                        seekNext(lvp);\n                                } else {\n                                    lastPosition = seekNext(lvp);\n                                }\n                                if (clickPosition < lastPosition) {\n                                    if (isMask(clickPosition))\n                                        caret(input, clickPosition);\n                                    else caret(input, seekNext(clickPosition));\n                                } else\n                                    caret(input, lastPosition);\n                            }\n                        }, 0);\n                    }).bind('dblclick.inputmask', function () {\n                        var input = this;\n                        setTimeout(function () {\n                            caret(input, 0, seekNext(getActiveMaskSet()[\"lastValidPosition\"]));\n                        }, 0);\n                    }).bind(pasteEvent + \".inputmask dragdrop.inputmask drop.inputmask\", function (e) {\n                        if (skipInputEvent === true) {\n                            skipInputEvent = false;\n                            return true;\n                        }\n                        var input = this, $input = $(input);\n\n                        //paste event for IE8 and lower I guess ;-)\n                        if (e.type == \"propertychange\" && input._valueGet().length <= getMaskLength()) {\n                            return true;\n                        }\n                        setTimeout(function () {\n                            var pasteValue = opts.onBeforePaste != undefined ? opts.onBeforePaste.call(this, input._valueGet()) : input._valueGet();\n                            checkVal(input, true, false, pasteValue.split(''), true);\n                            if (isComplete(getActiveBuffer()) === true)\n                                $input.trigger(\"complete\");\n                            $input.click();\n                        }, 0);\n                    }).bind('setvalue.inputmask', function () {\n                        var input = this;\n                        checkVal(input, true);\n                        valueOnFocus = getActiveBuffer().join('');\n                        if (input._valueGet() == getActiveBufferTemplate().join(''))\n                            input._valueSet('');\n                    }).bind('complete.inputmask', opts.oncomplete\n                    ).bind('incomplete.inputmask', opts.onincomplete\n                    ).bind('cleared.inputmask', opts.oncleared\n                    ).bind(\"keyup.inputmask\", keyupEvent);\n\n                    if (androidchrome) {\n                        $el.bind(\"input.inputmask\", inputEvent);\n                    } else {\n                        $el.bind(\"keydown.inputmask\", keydownEvent\n                        ).bind(\"keypress.inputmask\", keypressEvent);\n                    }\n\n                    if (msie10)\n                        $el.bind(\"input.inputmask\", inputEvent);\n\n                    //apply mask\n                    checkVal(el, true, false);\n                    valueOnFocus = getActiveBuffer().join('');\n                    // Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\n                    var activeElement;\n                    try {\n                        activeElement = document.activeElement;\n                    } catch (e) {\n                    }\n                    if (activeElement === el) { //position the caret when in focus\n                        $el.addClass('focus.inputmask');\n                        caret(el, seekNext(getActiveMaskSet()[\"lastValidPosition\"]));\n                    } else if (opts.clearMaskOnLostFocus) {\n                        if (getActiveBuffer().join('') == getActiveBufferTemplate().join('')) {\n                            el._valueSet('');\n                        } else {\n                            clearOptionalTail(el);\n                        }\n                    } else {\n                        writeBuffer(el, getActiveBuffer());\n                    }\n\n                    installEventRuler(el);\n                }\n            }\n\n            //action object\n            if (actionObj != undefined) {\n                switch (actionObj[\"action\"]) {\n                    case \"isComplete\":\n                        return isComplete(actionObj[\"buffer\"]);\n                    case \"unmaskedvalue\":\n                        isRTL = actionObj[\"$input\"].data('_inputmask')['isRTL'];\n                        return unmaskedvalue(actionObj[\"$input\"], actionObj[\"skipDatepickerCheck\"]);\n                    case \"mask\":\n                        mask(actionObj[\"el\"]);\n                        break;\n                    case \"format\":\n                        $el = $({});\n                        $el.data('_inputmask', {\n                            'masksets': masksets,\n                            'activeMasksetIndex': activeMasksetIndex,\n                            'opts': opts,\n                            'isRTL': opts.numericInput\n                        });\n                        if (opts.numericInput) {\n                            opts.isNumeric = opts.numericInput;\n                            isRTL = true;\n                        }\n\n                        checkVal($el, false, false, actionObj[\"value\"].split(''), true);\n                        return getActiveBuffer().join('');\n                }\n            }\n        }\n        $.inputmask = {\n            //options default\n            defaults: {\n                placeholder: \"_\",\n                optionalmarker: { start: \"[\", end: \"]\" },\n                quantifiermarker: { start: \"{\", end: \"}\" },\n                groupmarker: { start: \"(\", end: \")\" },\n                escapeChar: \"\\\\\",\n                mask: null,\n                oncomplete: $.noop, //executes when the mask is complete\n                onincomplete: $.noop, //executes when the mask is incomplete and focus is lost\n                oncleared: $.noop, //executes when the mask is cleared\n                repeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\n                greedy: true, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\n                autoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\n                clearMaskOnLostFocus: true,\n                insertMode: true, //insert the input or overwrite the input\n                clearIncomplete: false, //clear the incomplete input on blur\n                aliases: {}, //aliases definitions => see jquery.inputmask.extensions.js\n                onKeyUp: $.noop, //override to implement autocomplete on certain keys for example\n                onKeyDown: $.noop, //override to implement autocomplete on certain keys for example\n                onBeforePaste: undefined, //executes before masking the pasted value to allow preprocessing of the pasted value.  args => pastedValue => return processedValue\n                onUnMask: undefined, //executes after unmasking to allow postprocessing of the unmaskedvalue.  args => maskedValue, unmaskedValue\n                showMaskOnFocus: true, //show the mask-placeholder when the input has focus\n                showMaskOnHover: true, //show the mask-placeholder when hovering the empty input\n                onKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: result, opts\n                skipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\n                showTooltip: false, //show the activemask as tooltip\n                numericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\n                //numeric basic properties\n                isNumeric: false, //enable numeric features\n                radixPoint: \"\", //\".\", // | \",\"\n                skipRadixDance: false, //disable radixpoint caret positioning\n                rightAlignNumerics: true, //align numerics to the right\n                //numeric basic properties\n                definitions: {\n                    '9': {\n                        validator: \"[0-9]\",\n                        cardinality: 1\n                    },\n                    'a': {\n                        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451]\",\n                        cardinality: 1\n                    },\n                    '*': {\n                        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u04510-9]\",\n                        cardinality: 1\n                    }\n                },\n                keyCode: {\n                    ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108,\n                    NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91\n                },\n                //specify keycodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\n                ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],\n                getMaskLength: function (buffer, greedy, repeat, currentBuffer, opts) {\n                    var calculatedLength = buffer.length;\n                    if (!greedy) {\n                        if (repeat == \"*\") {\n                            calculatedLength = currentBuffer.length + 1;\n                        } else if (repeat > 1) {\n                            calculatedLength += (buffer.length * (repeat - 1));\n                        }\n                    }\n                    return calculatedLength;\n                }\n            },\n            escapeRegex: function (str) {\n                var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n                return str.replace(new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'gim'), '\\\\$1');\n            },\n            format: function (value, options) {\n                var opts = $.extend(true, {}, $.inputmask.defaults, options);\n                resolveAlias(opts.alias, options, opts);\n                return maskScope(generateMaskSets(opts), 0, opts, { \"action\": \"format\", \"value\": value });\n            }\n        };\n\n        $.fn.inputmask = function (fn, options) {\n            var opts = $.extend(true, {}, $.inputmask.defaults, options),\n                masksets,\n                activeMasksetIndex = 0;\n\n            if (typeof fn === \"string\") {\n                switch (fn) {\n                    case \"mask\":\n                        //resolve possible aliases given by options\n                        resolveAlias(opts.alias, options, opts);\n                        masksets = generateMaskSets(opts);\n                        if (masksets.length == 0) { return this; }\n\n                        return this.each(function () {\n                            maskScope($.extend(true, {}, masksets), 0, opts, { \"action\": \"mask\", \"el\": this });\n                        });\n                    case \"unmaskedvalue\":\n                        var $input = $(this), input = this;\n                        if ($input.data('_inputmask')) {\n                            masksets = $input.data('_inputmask')['masksets'];\n                            activeMasksetIndex = $input.data('_inputmask')['activeMasksetIndex'];\n                            opts = $input.data('_inputmask')['opts'];\n                            return maskScope(masksets, activeMasksetIndex, opts, { \"action\": \"unmaskedvalue\", \"$input\": $input });\n                        } else return $input.val();\n                    case \"remove\":\n                        return this.each(function () {\n                            var $input = $(this), input = this;\n                            if ($input.data('_inputmask')) {\n                                masksets = $input.data('_inputmask')['masksets'];\n                                activeMasksetIndex = $input.data('_inputmask')['activeMasksetIndex'];\n                                opts = $input.data('_inputmask')['opts'];\n                                //writeout the unmaskedvalue\n                                input._valueSet(maskScope(masksets, activeMasksetIndex, opts, { \"action\": \"unmaskedvalue\", \"$input\": $input, \"skipDatepickerCheck\": true }));\n                                //clear data\n                                $input.removeData('_inputmask');\n                                //unbind all events\n                                $input.unbind(\".inputmask\");\n                                $input.removeClass('focus.inputmask');\n                                //restore the value property\n                                var valueProperty;\n                                if (Object.getOwnPropertyDescriptor)\n                                    valueProperty = Object.getOwnPropertyDescriptor(input, \"value\");\n                                if (valueProperty && valueProperty.get) {\n                                    if (input._valueGet) {\n                                        Object.defineProperty(input, \"value\", {\n                                            get: input._valueGet,\n                                            set: input._valueSet\n                                        });\n                                    }\n                                } else if (document.__lookupGetter__ && input.__lookupGetter__(\"value\")) {\n                                    if (input._valueGet) {\n                                        input.__defineGetter__(\"value\", input._valueGet);\n                                        input.__defineSetter__(\"value\", input._valueSet);\n                                    }\n                                }\n                                try { //try catch needed for IE7 as it does not supports deleting fns\n                                    delete input._valueGet;\n                                    delete input._valueSet;\n                                } catch (e) {\n                                    input._valueGet = undefined;\n                                    input._valueSet = undefined;\n\n                                }\n                            }\n                        });\n                        break;\n                    case \"getemptymask\": //return the default (empty) mask value, usefull for setting the default value in validation\n                        if (this.data('_inputmask')) {\n                            masksets = this.data('_inputmask')['masksets'];\n                            activeMasksetIndex = this.data('_inputmask')['activeMasksetIndex'];\n                            return masksets[activeMasksetIndex]['_buffer'].join('');\n                        }\n                        else return \"\";\n                    case \"hasMaskedValue\": //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value \n                        return this.data('_inputmask') ? !this.data('_inputmask')['opts'].autoUnmask : false;\n                    case \"isComplete\":\n                        masksets = this.data('_inputmask')['masksets'];\n                        activeMasksetIndex = this.data('_inputmask')['activeMasksetIndex'];\n                        opts = this.data('_inputmask')['opts'];\n                        return maskScope(masksets, activeMasksetIndex, opts, { \"action\": \"isComplete\", \"buffer\": this[0]._valueGet().split('') });\n                    case \"getmetadata\": //return mask metadata if exists\n                        if (this.data('_inputmask')) {\n                            masksets = this.data('_inputmask')['masksets'];\n                            activeMasksetIndex = this.data('_inputmask')['activeMasksetIndex'];\n                            return masksets[activeMasksetIndex]['metadata'];\n                        }\n                        else return undefined;\n                    default:\n                        //check if the fn is an alias\n                        if (!resolveAlias(fn, options, opts)) {\n                            //maybe fn is a mask so we try\n                            //set mask\n                            opts.mask = fn;\n                        }\n                        masksets = generateMaskSets(opts);\n                        if (masksets.length == 0) { return this; }\n                        return this.each(function () {\n                            maskScope($.extend(true, {}, masksets), activeMasksetIndex, opts, { \"action\": \"mask\", \"el\": this });\n                        });\n\n                        break;\n                }\n            } else if (typeof fn == \"object\") {\n                opts = $.extend(true, {}, $.inputmask.defaults, fn);\n\n                resolveAlias(opts.alias, fn, opts); //resolve aliases\n                masksets = generateMaskSets(opts);\n                if (masksets.length == 0) { return this; }\n                return this.each(function () {\n                    maskScope($.extend(true, {}, masksets), activeMasksetIndex, opts, { \"action\": \"mask\", \"el\": this });\n                });\n            } else if (fn == undefined) {\n                //look for data-inputmask atribute - the attribute should only contain optipns\n                return this.each(function () {\n                    var attrOptions = $(this).attr(\"data-inputmask\");\n                    if (attrOptions && attrOptions != \"\") {\n                        try {\n                            attrOptions = attrOptions.replace(new RegExp(\"'\", \"g\"), '\"');\n                            var dataoptions = $.parseJSON(\"{\" + attrOptions + \"}\");\n                            $.extend(true, dataoptions, options);\n                            opts = $.extend(true, {}, $.inputmask.defaults, dataoptions);\n                            resolveAlias(opts.alias, dataoptions, opts);\n                            opts.alias = undefined;\n                            $(this).inputmask(opts);\n                        } catch (ex) { } //need a more relax parseJSON\n                    }\n                });\n            }\n        };\n    }\n})(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2Jvd2VyL0FkbWluTFRFL3BsdWdpbnMvaW5wdXQtbWFzay9qcXVlcnkuaW5wdXRtYXNrLmpzP2ZmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEBsaWNlbnNlIElucHV0IE1hc2sgcGx1Z2luIGZvciBqcXVlcnlcbiogaHR0cDovL2dpdGh1Yi5jb20vUm9iaW5IZXJib3RzL2pxdWVyeS5pbnB1dG1hc2tcbiogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNCBSb2JpbiBIZXJib3RzXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4qIFZlcnNpb246IDAuMC4wXG4qL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICBpZiAoJC5mbi5pbnB1dG1hc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL2hlbHBlciBmdW5jdGlvbnMgICAgXG4gICAgICAgIGZ1bmN0aW9uIGlzSW5wdXRFdmVudFN1cHBvcnRlZChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JyksXG4gICAgICAgICAgICBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lLFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGVsKTtcbiAgICAgICAgICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgICAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsW2V2ZW50TmFtZV0gPT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlQWxpYXMoYWxpYXNTdHIsIG9wdGlvbnMsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBhbGlhc0RlZmluaXRpb24gPSBvcHRzLmFsaWFzZXNbYWxpYXNTdHJdO1xuICAgICAgICAgICAgaWYgKGFsaWFzRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChhbGlhc0RlZmluaXRpb24uYWxpYXMpIHJlc29sdmVBbGlhcyhhbGlhc0RlZmluaXRpb24uYWxpYXMsIHVuZGVmaW5lZCwgb3B0cyk7IC8vYWxpYXMgaXMgYW5vdGhlciBhbGlhc1xuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdHMsIGFsaWFzRGVmaW5pdGlvbik7ICAvL21lcmdlIGFsaWFzIGRlZmluaXRpb24gaW4gdGhlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRzLCBvcHRpb25zKTsgIC8vcmVhcHBseSBleHRyYSBnaXZlbiBvcHRpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVNYXNrU2V0cyhvcHRzKSB7XG4gICAgICAgICAgICB2YXIgbXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBnZW5tYXNrcyA9IFtdOyAvL3VzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgbWFza3MgdGhhdCB3aGVyZSBwcm9jZXNzZWQsIHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE1hc2tUZW1wbGF0ZShtYXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMubnVtZXJpY0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSBtYXNrLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG91dENvdW50ID0gMCwgZ3JlZWR5ID0gb3B0cy5ncmVlZHksIHJlcGVhdCA9IG9wdHMucmVwZWF0O1xuICAgICAgICAgICAgICAgIGlmIChyZXBlYXQgPT0gXCIqXCIpIGdyZWVkeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vaWYgKGdyZWVkeSA9PSB0cnVlICYmIG9wdHMucGxhY2Vob2xkZXIgPT0gXCJcIikgb3B0cy5wbGFjZWhvbGRlciA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrLmxlbmd0aCA9PSAxICYmIGdyZWVkeSA9PSBmYWxzZSAmJiByZXBlYXQgIT0gMCkgeyBvcHRzLnBsYWNlaG9sZGVyID0gXCJcIjsgfSAvL2hpZGUgcGxhY2Vob2xkZXIgd2l0aCBzaW5nbGUgbm9uLWdyZWVkeSBtYXNrXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZU1hc2sgPSAkLm1hcChtYXNrLnNwbGl0KFwiXCIpLCBmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dEVsZW0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gb3B0cy5lc2NhcGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoZWxlbWVudCAhPSBvcHRzLm9wdGlvbmFsbWFya2VyLnN0YXJ0ICYmIGVsZW1lbnQgIT0gb3B0cy5vcHRpb25hbG1hcmtlci5lbmQpIHx8IGVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrZGVmID0gb3B0cy5kZWZpbml0aW9uc1tlbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrZGVmICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrZGVmLmNhcmRpbmFsaXR5OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0RWxlbS5wdXNoKG9wdHMucGxhY2Vob2xkZXIuY2hhckF0KChvdXRDb3VudCArIGkpICUgb3B0cy5wbGFjZWhvbGRlci5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dEVsZW0ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRDb3VudCArPSBvdXRFbGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRFbGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL2FsbG9jYXRlIHJlcGV0aXRpb25zXG4gICAgICAgICAgICAgICAgdmFyIHJlcGVhdGVkTWFzayA9IHNpbmdsZU1hc2suc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJlcGVhdCAmJiBncmVlZHk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXBlYXRlZE1hc2sgPSByZXBlYXRlZE1hc2suY29uY2F0KHNpbmdsZU1hc2suc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgXCJtYXNrXCI6IHJlcGVhdGVkTWFzaywgXCJyZXBlYXRcIjogcmVwZWF0LCBcImdyZWVkeVwiOiBncmVlZHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGVzdCBkZWZpbml0aW9uID0+IHtmbjogUmVnRXhwL2Z1bmN0aW9uLCBjYXJkaW5hbGl0eTogaW50LCBvcHRpb25hbGl0eTogYm9vbCwgbmV3QmxvY2tNYXJrZXI6IGJvb2wsIG9mZnNldDogaW50LCBjYXNpbmc6IG51bGwvdXBwZXIvbG93ZXIsIGRlZjogZGVmaW5pdGlvblN5bWJvbH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRlc3RpbmdDaGFpbihtYXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMubnVtZXJpY0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSBtYXNrLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2UsIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QmxvY2tNYXJrZXIgPSBmYWxzZTsgLy9pbmRpY2F0ZXMgd2hldGVyIHRoZSBiZWdpbi9lbmRpbmcgb2YgYSBibG9jayBzaG91bGQgYmUgaW5kaWNhdGVkXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJC5tYXAobWFzay5zcGxpdChcIlwiKSwgZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRFbGVtID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gb3B0cy5lc2NhcGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09IG9wdHMub3B0aW9uYWxtYXJrZXIuc3RhcnQgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2tNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQgPT0gb3B0cy5vcHRpb25hbG1hcmtlci5lbmQgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Jsb2NrTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrZGVmID0gb3B0cy5kZWZpbml0aW9uc1tlbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrZGVmICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZhbGlkYXRvcnMgPSBtYXNrZGVmW1wicHJldmFsaWRhdG9yXCJdLCBwcmV2YWxpZGF0b3JzTCA9IHByZXZhbGlkYXRvcnMgPyBwcmV2YWxpZGF0b3JzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXNrZGVmLmNhcmRpbmFsaXR5OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZhbGlkYXRvciA9IHByZXZhbGlkYXRvcnNMID49IGkgPyBwcmV2YWxpZGF0b3JzW2kgLSAxXSA6IFtdLCB2YWxpZGF0b3IgPSBwcmV2YWxpZGF0b3JbXCJ2YWxpZGF0b3JcIl0sIGNhcmRpbmFsaXR5ID0gcHJldmFsaWRhdG9yW1wiY2FyZGluYWxpdHlcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dEVsZW0ucHVzaCh7IGZuOiB2YWxpZGF0b3IgPyB0eXBlb2YgdmFsaWRhdG9yID09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cCh2YWxpZGF0b3IpIDogbmV3IGZ1bmN0aW9uICgpIHsgdGhpcy50ZXN0ID0gdmFsaWRhdG9yOyB9IDogbmV3IFJlZ0V4cChcIi5cIiksIGNhcmRpbmFsaXR5OiBjYXJkaW5hbGl0eSA/IGNhcmRpbmFsaXR5IDogMSwgb3B0aW9uYWxpdHk6IGlzT3B0aW9uYWwsIG5ld0Jsb2NrTWFya2VyOiBpc09wdGlvbmFsID09IHRydWUgPyBuZXdCbG9ja01hcmtlciA6IGZhbHNlLCBvZmZzZXQ6IDAsIGNhc2luZzogbWFza2RlZltcImNhc2luZ1wiXSwgZGVmOiBtYXNrZGVmW1wiZGVmaW5pdGlvblN5bWJvbFwiXSB8fCBlbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCA9PSB0cnVlKSAvL3Jlc2V0IG5ld0Jsb2NrTWFya2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCbG9ja01hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRFbGVtLnB1c2goeyBmbjogbWFza2RlZi52YWxpZGF0b3IgPyB0eXBlb2YgbWFza2RlZi52YWxpZGF0b3IgPT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKG1hc2tkZWYudmFsaWRhdG9yKSA6IG5ldyBmdW5jdGlvbiAoKSB7IHRoaXMudGVzdCA9IG1hc2tkZWYudmFsaWRhdG9yOyB9IDogbmV3IFJlZ0V4cChcIi5cIiksIGNhcmRpbmFsaXR5OiBtYXNrZGVmLmNhcmRpbmFsaXR5LCBvcHRpb25hbGl0eTogaXNPcHRpb25hbCwgbmV3QmxvY2tNYXJrZXI6IG5ld0Jsb2NrTWFya2VyLCBvZmZzZXQ6IDAsIGNhc2luZzogbWFza2RlZltcImNhc2luZ1wiXSwgZGVmOiBtYXNrZGVmW1wiZGVmaW5pdGlvblN5bWJvbFwiXSB8fCBlbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRFbGVtLnB1c2goeyBmbjogbnVsbCwgY2FyZGluYWxpdHk6IDAsIG9wdGlvbmFsaXR5OiBpc09wdGlvbmFsLCBuZXdCbG9ja01hcmtlcjogbmV3QmxvY2tNYXJrZXIsIG9mZnNldDogMCwgY2FzaW5nOiBudWxsLCBkZWY6IGVsZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXNldCBuZXdCbG9ja01hcmtlclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmxvY2tNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRFbGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBtYXJrT3B0aW9uYWwobWFza1BhcnQpIHsgLy9uZWVkZWQgZm9yIHRoZSBjbGVhck9wdGlvbmFsVGFpbCBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMub3B0aW9uYWxtYXJrZXIuc3RhcnQgKyBtYXNrUGFydCArIG9wdHMub3B0aW9uYWxtYXJrZXIuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc3BsaXRGaXJzdE9wdGlvbmFsRW5kUGFydChtYXNrUGFydCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25hbFN0YXJ0TWFya2VycyA9IDAsIG9wdGlvbmFsRW5kTWFya2VycyA9IDAsIG1wbCA9IG1hc2tQYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1wbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXNrUGFydC5jaGFyQXQoaSkgPT0gb3B0cy5vcHRpb25hbG1hcmtlci5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxTdGFydE1hcmtlcnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWFza1BhcnQuY2hhckF0KGkpID09IG9wdHMub3B0aW9uYWxtYXJrZXIuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZE1hcmtlcnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWxTdGFydE1hcmtlcnMgPiAwICYmIG9wdGlvbmFsU3RhcnRNYXJrZXJzID09IG9wdGlvbmFsRW5kTWFya2VycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWFza1BhcnRzID0gW21hc2tQYXJ0LnN1YnN0cmluZygwLCBpKV07XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBtcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza1BhcnRzLnB1c2gobWFza1BhcnQuc3Vic3RyaW5nKGkgKyAxLCBtcGwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hc2tQYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNwbGl0Rmlyc3RPcHRpb25hbFN0YXJ0UGFydChtYXNrUGFydCkge1xuICAgICAgICAgICAgICAgIHZhciBtcGwgPSBtYXNrUGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtcGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFza1BhcnQuY2hhckF0KGkpID09IG9wdHMub3B0aW9uYWxtYXJrZXIuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtYXNrUGFydHMgPSBbbWFza1BhcnQuc3Vic3RyaW5nKDAsIGkpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG1wbCkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrUGFydHMucHVzaChtYXNrUGFydC5zdWJzdHJpbmcoaSArIDEsIG1wbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFza1BhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVNYXNrKG1hc2tQcmVmaXgsIG1hc2tQYXJ0LCBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXNrUGFydHMgPSBzcGxpdEZpcnN0T3B0aW9uYWxFbmRQYXJ0KG1hc2tQYXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TWFzaywgbWFza1RlbXBsYXRlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hc2tzID0gc3BsaXRGaXJzdE9wdGlvbmFsU3RhcnRQYXJ0KG1hc2tQYXJ0c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWFzayA9IG1hc2tQcmVmaXggKyBtYXNrc1swXSArIG1hcmtPcHRpb25hbChtYXNrc1sxXSkgKyAobWFza1BhcnRzLmxlbmd0aCA+IDEgPyBtYXNrUGFydHNbMV0gOiBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShuZXdNYXNrLCBnZW5tYXNrcykgPT0gLTEgJiYgbmV3TWFzayAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5tYXNrcy5wdXNoKG5ld01hc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza1RlbXBsYXRlID0gZ2V0TWFza1RlbXBsYXRlKG5ld01hc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXNrXCI6IG5ld01hc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJfYnVmZmVyXCI6IG1hc2tUZW1wbGF0ZVtcIm1hc2tcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJidWZmZXJcIjogbWFza1RlbXBsYXRlW1wibWFza1wiXS5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGVzdHNcIjogZ2V0VGVzdGluZ0NoYWluKG5ld01hc2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFzdFZhbGlkUG9zaXRpb25cIjogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJncmVlZHlcIjogbWFza1RlbXBsYXRlW1wiZ3JlZWR5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVwZWF0XCI6IG1hc2tUZW1wbGF0ZVtcInJlcGVhdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdNYXNrID0gbWFza1ByZWZpeCArIG1hc2tzWzBdICsgKG1hc2tQYXJ0cy5sZW5ndGggPiAxID8gbWFza1BhcnRzWzFdIDogXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkobmV3TWFzaywgZ2VubWFza3MpID09IC0xICYmIG5ld01hc2sgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VubWFza3MucHVzaChuZXdNYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tUZW1wbGF0ZSA9IGdldE1hc2tUZW1wbGF0ZShuZXdNYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFza1wiOiBuZXdNYXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiX2J1ZmZlclwiOiBtYXNrVGVtcGxhdGVbXCJtYXNrXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnVmZmVyXCI6IG1hc2tUZW1wbGF0ZVtcIm1hc2tcIl0uc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRlc3RzXCI6IGdldFRlc3RpbmdDaGFpbihuZXdNYXNrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxhc3RWYWxpZFBvc2l0aW9uXCI6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3JlZWR5XCI6IG1hc2tUZW1wbGF0ZVtcImdyZWVkeVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlcGVhdFwiOiBtYXNrVGVtcGxhdGVbXCJyZXBlYXRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0Rmlyc3RPcHRpb25hbFN0YXJ0UGFydChtYXNrc1sxXSkubGVuZ3RoID4gMSkgeyAvL29wdGlvbmFsIGNvbnRhaW5zIGFub3RoZXIgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWFzayhtYXNrUHJlZml4ICsgbWFza3NbMF0sIG1hc2tzWzFdICsgbWFza1BhcnRzWzFdLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQYXJ0cy5sZW5ndGggPiAxICYmIHNwbGl0Rmlyc3RPcHRpb25hbFN0YXJ0UGFydChtYXNrUGFydHNbMV0pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWFzayhtYXNrUHJlZml4ICsgbWFza3NbMF0gKyBtYXJrT3B0aW9uYWwobWFza3NbMV0pLCBtYXNrUGFydHNbMV0sIG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWFzayhtYXNrUHJlZml4ICsgbWFza3NbMF0sIG1hc2tQYXJ0c1sxXSwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXNrID0gbWFza1ByZWZpeCArIG1hc2tQYXJ0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShuZXdNYXNrLCBnZW5tYXNrcykgPT0gLTEgJiYgbmV3TWFzayAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5tYXNrcy5wdXNoKG5ld01hc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza1RlbXBsYXRlID0gZ2V0TWFza1RlbXBsYXRlKG5ld01hc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXNrXCI6IG5ld01hc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJfYnVmZmVyXCI6IG1hc2tUZW1wbGF0ZVtcIm1hc2tcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJidWZmZXJcIjogbWFza1RlbXBsYXRlW1wibWFza1wiXS5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGVzdHNcIjogZ2V0VGVzdGluZ0NoYWluKG5ld01hc2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFzdFZhbGlkUG9zaXRpb25cIjogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJncmVlZHlcIjogbWFza1RlbXBsYXRlW1wiZ3JlZWR5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVwZWF0XCI6IG1hc2tUZW1wbGF0ZVtcInJlcGVhdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKG9wdHMubWFzaykpIHsgLy9hbGxvdyBtYXNrIHRvIGJlIGEgcHJlcHJvY2Vzc2luZyBmbiAtIHNob3VsZCByZXR1cm4gYSB2YWxpZCBtYXNrXG4gICAgICAgICAgICAgICAgb3B0cy5tYXNrID0gb3B0cy5tYXNrLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC5pc0FycmF5KG9wdHMubWFzaykpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2gob3B0cy5tYXNrLCBmdW5jdGlvbiAobmR4LCBtc2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1za1tcIm1hc2tcIl0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1hc2soXCJcIiwgbXNrW1wibWFza1wiXS50b1N0cmluZygpLCBtc2spO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWFzayhcIlwiLCBtc2sudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgZ2VuZXJhdGVNYXNrKFwiXCIsIG9wdHMubWFzay50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdHMuZ3JlZWR5ID8gbXMgOiBtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhW1wibWFza1wiXS5sZW5ndGggLSBiW1wibWFza1wiXS5sZW5ndGg7IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1zaWUxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gobmV3IFJlZ0V4cChcIm1zaWUgMTBcIiwgXCJpXCIpKSAhPT0gbnVsbCxcbiAgICAgICAgICAgIGlwaG9uZSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gobmV3IFJlZ0V4cChcImlwaG9uZVwiLCBcImlcIikpICE9PSBudWxsLFxuICAgICAgICAgICAgYW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gobmV3IFJlZ0V4cChcImFuZHJvaWQuKnNhZmFyaS4qXCIsIFwiaVwiKSkgIT09IG51bGwsXG4gICAgICAgICAgICBhbmRyb2lkY2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChuZXcgUmVnRXhwKFwiYW5kcm9pZC4qY2hyb21lLipcIiwgXCJpXCIpKSAhPT0gbnVsbCxcbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBpc0lucHV0RXZlbnRTdXBwb3J0ZWQoJ3Bhc3RlJykgPyAncGFzdGUnIDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkKCdpbnB1dCcpID8gJ2lucHV0JyA6IFwicHJvcGVydHljaGFuZ2VcIjtcblxuXG4gICAgICAgIC8vbWFza2luZyBzY29wZVxuICAgICAgICAvL2FjdGlvbk9iaiBkZWZpbml0aW9uIHNlZSBiZWxvd1xuICAgICAgICBmdW5jdGlvbiBtYXNrU2NvcGUobWFza3NldHMsIGFjdGl2ZU1hc2tzZXRJbmRleCwgb3B0cywgYWN0aW9uT2JqKSB7XG4gICAgICAgICAgICB2YXIgaXNSVEwgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZU9uRm9jdXMgPSBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICAkZWwsIGNocm9tZVZhbHVlT25JbnB1dCxcbiAgICAgICAgICAgICAgICBza2lwS2V5UHJlc3NFdmVudCA9IGZhbHNlLCAvL1NhZmFyaSA1LjEueCAtIG1vZGFsIGRpYWxvZyBmaXJlcyBrZXlwcmVzcyB0d2ljZSB3b3JrYXJvdW5kXG4gICAgICAgICAgICAgICAgc2tpcElucHV0RXZlbnQgPSBmYWxzZSwgLy9za2lwIHdoZW4gdHJpZ2dlcmVkIGZyb20gd2l0aGluIGlucHV0bWFza1xuICAgICAgICAgICAgICAgIGlnbm9yYWJsZSA9IGZhbHNlO1xuXG5cbiAgICAgICAgICAgIC8vbWFza3NldCBoZWxwZXJmdW5jdGlvbnNcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWN0aXZlTWFza1NldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFza3NldHNbYWN0aXZlTWFza3NldEluZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWN0aXZlVGVzdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZU1hc2tTZXQoKVsndGVzdHMnXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZU1hc2tTZXQoKVsnX2J1ZmZlciddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRBY3RpdmVCdWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFjdGl2ZU1hc2tTZXQoKVsnYnVmZmVyJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzVmFsaWQocG9zLCBjLCBzdHJpY3QpIHsgLy9zdHJpY3QgdHJ1ZSB+IG5vIGNvcnJlY3Rpb24gb3IgYXV0b2ZpbGxcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSBzdHJpY3QgPT09IHRydWU7IC8vYWx3YXlzIHNldCBhIHZhbHVlIHRvIHN0cmljdCB0byBwcmV2ZW50IHBvc3NpYmxlIHN0cmFuZ2UgYmVoYXZpb3IgaW4gdGhlIGV4dGVuc2lvbnMgXG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfaXNWYWxpZChwb3NpdGlvbiwgYWN0aXZlTWFza3NldCwgYywgc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0UG9zID0gZGV0ZXJtaW5lVGVzdFBvc2l0aW9uKHBvc2l0aW9uKSwgbG9vcGVuZCA9IGMgPyAxIDogMCwgY2hycyA9ICcnLCBidWZmZXIgPSBhY3RpdmVNYXNrc2V0W1wiYnVmZmVyXCJdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYWN0aXZlTWFza3NldFsndGVzdHMnXVt0ZXN0UG9zXS5jYXJkaW5hbGl0eTsgaSA+IGxvb3BlbmQ7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hycyArPSBnZXRCdWZmZXJFbGVtZW50KGJ1ZmZlciwgdGVzdFBvcyAtIChpIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocnMgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGlzIGZhbHNlIG9yIGEganNvbiBvYmplY3QgPT4geyBwb3M6ID8/LCBjOiA/P30gb3IgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aXZlTWFza3NldFsndGVzdHMnXVt0ZXN0UG9zXS5mbiAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRbJ3Rlc3RzJ11bdGVzdFBvc10uZm4udGVzdChjaHJzLCBidWZmZXIsIHBvc2l0aW9uLCBzdHJpY3QsIG9wdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChjID09IGdldEJ1ZmZlckVsZW1lbnQoYWN0aXZlTWFza3NldFsnX2J1ZmZlciddLCBwb3NpdGlvbiwgdHJ1ZSkgfHwgYyA9PSBvcHRzLnNraXBPcHRpb25hbFBhcnRDaGFyYWN0ZXIpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwicmVmcmVzaFwiOiB0cnVlLCBjOiBnZXRCdWZmZXJFbGVtZW50KGFjdGl2ZU1hc2tzZXRbJ19idWZmZXInXSwgcG9zaXRpb24sIHRydWUpLCBwb3M6IHBvc2l0aW9uIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFBvc3RQcm9jZXNzUmVzdWx0cyhtYXNrRm9yd2FyZHMsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1ZhbGlkQWN0dWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChyZXN1bHRzLCBmdW5jdGlvbiAobmR4LCByc2x0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNWYWxpZEFjdHVhbCA9ICQuaW5BcnJheShyc2x0W1wiYWN0aXZlTWFza3NldEluZGV4XCJdLCBtYXNrRm9yd2FyZHMpID09IC0xICYmIHJzbHRbXCJyZXN1bHRcIl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZhbGlkQWN0dWFsKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVmFsaWRBY3R1YWwpIHsgLy9zdHJpcCBtYXNrZm9yd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSAkLm1hcChyZXN1bHRzLCBmdW5jdGlvbiAocnNsdCwgbmR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShyc2x0W1wiYWN0aXZlTWFza3NldEluZGV4XCJdLCBtYXNrRm9yd2FyZHMpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByc2x0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tzZXRzW3JzbHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl1dW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gPSBhY3R1YWxMVlA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8va2VlcCBtYXNrZm9yd2FyZHMgd2l0aCB0aGUgbGVhc3QgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VzdFBvcyA9IC0xLCBsb3dlc3RJbmRleCA9IC0xLCByc2x0VmFsaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKG5keCwgcnNsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkocnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXSwgbWFza0ZvcndhcmRzKSAhPSAtMSAmJiByc2x0W1wicmVzdWx0XCJdICE9PSBmYWxzZSAmIChsb3dlc3RQb3MgPT0gLTEgfHwgbG93ZXN0UG9zID4gcnNsdFtcInJlc3VsdFwiXVtcInBvc1wiXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zID0gcnNsdFtcInJlc3VsdFwiXVtcInBvc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0SW5kZXggPSByc2x0W1wiYWN0aXZlTWFza3NldEluZGV4XCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9ICQubWFwKHJlc3VsdHMsIGZ1bmN0aW9uIChyc2x0LCBuZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHJzbHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl0sIG1hc2tGb3J3YXJkcykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzbHRbXCJyZXN1bHRcIl1bXCJwb3NcIl0gPT0gbG93ZXN0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnNsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyc2x0W1wicmVzdWx0XCJdICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGxvd2VzdFBvczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnNsdFZhbGlkID0gX2lzVmFsaWQoaSwgbWFza3NldHNbcnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXV0sIG1hc2tzZXRzW2xvd2VzdEluZGV4XVtcImJ1ZmZlclwiXVtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzbHRWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza3NldHNbcnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXV1bXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA9IGxvd2VzdFBvcyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ1ZmZlckVsZW1lbnQobWFza3NldHNbcnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXV1bXCJidWZmZXJcIl0sIGksIG1hc2tzZXRzW2xvd2VzdEluZGV4XVtcImJ1ZmZlclwiXVtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tzZXRzW3JzbHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl1dW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxzbyBjaGVjayBjaGVjayBmb3IgdGhlIGxvd2VzdHBvcyB3aXRoIHRoZSBuZXcgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzbHRWYWxpZCA9IF9pc1ZhbGlkKGxvd2VzdFBvcywgbWFza3NldHNbcnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXV0sIGMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzbHRWYWxpZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCdWZmZXJFbGVtZW50KG1hc2tzZXRzW3JzbHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl1dW1wiYnVmZmVyXCJdLCBsb3dlc3RQb3MsIGMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tzZXRzW3JzbHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl1dW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gPSBsb3dlc3RQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibmR4IFwiICsgcnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXSArIFwiIHZhbGlkYXRlIFwiICsgbWFza3NldHNbcnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXV1bXCJidWZmZXJcIl0uam9pbignJykgKyBcIiBsdiBcIiArIG1hc2tzZXRzW3JzbHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl1dWydsYXN0VmFsaWRQb3NpdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByc2x0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2lzVmFsaWQocG9zLCBnZXRBY3RpdmVNYXNrU2V0KCksIGMsIHN0cmljdCk7IC8vb25seSBjaGVjayB2YWxpZGl0eSBpbiBjdXJyZW50IG1hc2sgd2hlbiB2YWxpZGF0aW5nIHN0cmljdFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7IFwicG9zXCI6IHBvcyB9OyAvL2Fsd2F5cyB0YWtlIGEgcG9zc2libGUgY29ycmVjdGVkIG1hc2twb3NpdGlvbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10sIHJlc3VsdCA9IGZhbHNlLCBjdXJyZW50QWN0aXZlTWFza3NldEluZGV4ID0gYWN0aXZlTWFza3NldEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxCdWZmZXIgPSBnZXRBY3RpdmVCdWZmZXIoKS5zbGljZSgpLCBhY3R1YWxMVlAgPSBnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsUHJldmlvdXMgPSBzZWVrUHJldmlvdXMocG9zKSxcbiAgICAgICAgICAgICAgICAgICAgbWFza0ZvcndhcmRzID0gW107XG4gICAgICAgICAgICAgICAgJC5lYWNoKG1hc2tzZXRzLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbHZwID0gZ2V0QWN0aXZlTWFza1NldCgpWydsYXN0VmFsaWRQb3NpdGlvbiddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzbHRWYWxpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsdnAgPT0gYWN0dWFsTFZQKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXNrUG9zIC0gYWN0dWFsTFZQKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGx2cCA9PSAtMSA/IDAgOiBsdnA7IGkgPCBtYXNrUG9zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzbHRWYWxpZCA9IF9pc1ZhbGlkKGksIGdldEFjdGl2ZU1hc2tTZXQoKSwgYWN0dWFsQnVmZmVyW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyc2x0VmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ1ZmZlckVsZW1lbnQoZ2V0QWN0aXZlQnVmZmVyKCksIGksIGFjdHVhbEJ1ZmZlcltpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzbHRWYWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByc2x0VmFsaWQgPSB7IFwicG9zXCI6IGkgfTsgLy9hbHdheXMgdGFrZSBhIHBvc3NpYmxlIGNvcnJlY3RlZCBtYXNrcG9zaXRpb24gaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWxpZFBvc2l0aW9uID0gcnNsdFZhbGlkLnBvcyB8fCBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3RpdmVNYXNrU2V0KClbJ2xhc3RWYWxpZFBvc2l0aW9uJ10gPCBuZXdWYWxpZFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbJ2xhc3RWYWxpZFBvc2l0aW9uJ10gPSBuZXdWYWxpZFBvc2l0aW9uOyAvL3NldCBuZXcgcG9zaXRpb24gZnJvbSBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kb2VzIHRoZSBpbnB1dCBtYXRjaCBvbiBhIGZ1cnRoZXIgcG9zaXRpb24/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01hc2sobWFza1BvcykgJiYgIV9pc1ZhbGlkKG1hc2tQb3MsIGdldEFjdGl2ZU1hc2tTZXQoKSwgYywgc3RyaWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Rm9yd2FyZCA9IHNlZWtOZXh0KG1hc2tQb3MpIC0gbWFza1BvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZncgPSAwOyBmdyA8IG1heEZvcndhcmQ7IGZ3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNWYWxpZCgrK21hc2tQb3MsIGdldEFjdGl2ZU1hc2tTZXQoKSwgYywgc3RyaWN0KSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0ZvcndhcmRzLnB1c2goYWN0aXZlTWFza3NldEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbWFza2ZvcndhcmQgJyArIGFjdGl2ZU1hc2tzZXRJbmRleCArIFwiIHBvcyBcIiArIHBvcyArIFwiIG1hc2tQb3MgXCIgKyBtYXNrUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3RpdmVNYXNrU2V0KClbJ2xhc3RWYWxpZFBvc2l0aW9uJ10gPj0gYWN0dWFsTFZQIHx8IGFjdGl2ZU1hc2tzZXRJbmRleCA9PSBjdXJyZW50QWN0aXZlTWFza3NldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQb3MgPj0gMCAmJiBtYXNrUG9zIDwgZ2V0TWFza0xlbmd0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9pc1ZhbGlkKG1hc2tQb3MsIGdldEFjdGl2ZU1hc2tTZXQoKSwgYywgc3RyaWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7IFwicG9zXCI6IG1hc2tQb3MgfTsgLy9hbHdheXMgdGFrZSBhIHBvc3NpYmxlIGNvcnJlY3RlZCBtYXNrcG9zaXRpb24gaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsaWRQb3NpdGlvbiA9IHJlc3VsdC5wb3MgfHwgbWFza1BvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3RpdmVNYXNrU2V0KClbJ2xhc3RWYWxpZFBvc2l0aW9uJ10gPCBuZXdWYWxpZFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFjdGl2ZU1hc2tTZXQoKVsnbGFzdFZhbGlkUG9zaXRpb24nXSA9IG5ld1ZhbGlkUG9zaXRpb247IC8vc2V0IG5ldyBwb3NpdGlvbiBmcm9tIGlzVmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicG9zIFwiICsgcG9zICsgXCIgbmR4IFwiICsgYWN0aXZlTWFza3NldEluZGV4ICsgXCIgdmFsaWRhdGUgXCIgKyBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKSArIFwiIGx2IFwiICsgZ2V0QWN0aXZlTWFza1NldCgpWydsYXN0VmFsaWRQb3NpdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgXCJhY3RpdmVNYXNrc2V0SW5kZXhcIjogaW5kZXgsIFwicmVzdWx0XCI6IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSBjdXJyZW50QWN0aXZlTWFza3NldEluZGV4OyAvL3Jlc2V0IGFjdGl2ZU1hc2tzZXRJbmRleFxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvc3RQcm9jZXNzUmVzdWx0cyhtYXNrRm9yd2FyZHMsIHJlc3VsdHMpOyAvL3JldHVybiByZXN1bHRzIG9mIHRoZSBtdWx0aXBsZSBtYXNrIHZhbGlkYXRpb25zXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRldGVybWluZUFjdGl2ZU1hc2tzZXRJbmRleCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE1hc2tzZXRJbmRleCA9IGFjdGl2ZU1hc2tzZXRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFZhbGlkID0geyBcImFjdGl2ZU1hc2tzZXRJbmRleFwiOiAwLCBcImxhc3RWYWxpZFBvc2l0aW9uXCI6IC0xLCBcIm5leHRcIjogLTEgfTtcbiAgICAgICAgICAgICAgICAkLmVhY2gobWFza3NldHMsIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdGl2ZU1hc2tTZXQoKVsnbGFzdFZhbGlkUG9zaXRpb24nXSA+IGhpZ2hlc3RWYWxpZFsnbGFzdFZhbGlkUG9zaXRpb24nXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RWYWxpZFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RWYWxpZFtcImxhc3RWYWxpZFBvc2l0aW9uXCJdID0gZ2V0QWN0aXZlTWFza1NldCgpWydsYXN0VmFsaWRQb3NpdGlvbiddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RWYWxpZFtcIm5leHRcIl0gPSBzZWVrTmV4dChnZXRBY3RpdmVNYXNrU2V0KClbJ2xhc3RWYWxpZFBvc2l0aW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZXRBY3RpdmVNYXNrU2V0KClbJ2xhc3RWYWxpZFBvc2l0aW9uJ10gPT0gaGlnaGVzdFZhbGlkWydsYXN0VmFsaWRQb3NpdGlvbiddICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhpZ2hlc3RWYWxpZFsnbmV4dCddID09IC0xIHx8IGhpZ2hlc3RWYWxpZFsnbmV4dCddID4gc2Vla05leHQoZ2V0QWN0aXZlTWFza1NldCgpWydsYXN0VmFsaWRQb3NpdGlvbiddKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0VmFsaWRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0VmFsaWRbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA9IGdldEFjdGl2ZU1hc2tTZXQoKVsnbGFzdFZhbGlkUG9zaXRpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0VmFsaWRbXCJuZXh0XCJdID0gc2Vla05leHQoZ2V0QWN0aXZlTWFza1NldCgpWydsYXN0VmFsaWRQb3NpdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYWN0aXZlTWFza3NldEluZGV4ID0gaGlnaGVzdFZhbGlkW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gIT0gLTEgJiYgbWFza3NldHNbY3VycmVudE1hc2tzZXRJbmRleF1bXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA9PSBoaWdoZXN0VmFsaWRbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA/IGN1cnJlbnRNYXNrc2V0SW5kZXggOiBoaWdoZXN0VmFsaWRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNYXNrc2V0SW5kZXggIT0gYWN0aXZlTWFza3NldEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQnVmZmVyKGdldEFjdGl2ZUJ1ZmZlcigpLCBzZWVrTmV4dChoaWdoZXN0VmFsaWRbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSksIGdldE1hc2tMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIGdldEFjdGl2ZU1hc2tTZXQoKVtcIndyaXRlT3V0QnVmZmVyXCJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGVsLmRhdGEoJ19pbnB1dG1hc2snKVsnYWN0aXZlTWFza3NldEluZGV4J10gPSBhY3RpdmVNYXNrc2V0SW5kZXg7IC8vc3RvcmUgdGhlIGFjdGl2ZU1hc2tzZXRJbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc01hc2socG9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RQb3MgPSBkZXRlcm1pbmVUZXN0UG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IGdldEFjdGl2ZVRlc3RzKClbdGVzdFBvc107XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdCAhPSB1bmRlZmluZWQgPyB0ZXN0LmZuIDogZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRldGVybWluZVRlc3RQb3NpdGlvbihwb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zICUgZ2V0QWN0aXZlVGVzdHMoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE1hc2tMZW5ndGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuZ2V0TWFza0xlbmd0aChnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpLCBnZXRBY3RpdmVNYXNrU2V0KClbJ2dyZWVkeSddLCBnZXRBY3RpdmVNYXNrU2V0KClbJ3JlcGVhdCddLCBnZXRBY3RpdmVCdWZmZXIoKSwgb3B0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcG9zOiBmcm9tIHBvc2l0aW9uXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlZWtOZXh0KHBvcykge1xuICAgICAgICAgICAgICAgIHZhciBtYXNrTCA9IGdldE1hc2tMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IG1hc2tMKSByZXR1cm4gbWFza0w7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK3Bvc2l0aW9uIDwgbWFza0wgJiYgIWlzTWFzayhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3BvczogZnJvbSBwb3NpdGlvblxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzZWVrUHJldmlvdXMocG9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSAwKSByZXR1cm4gMDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgtLXBvc2l0aW9uID4gMCAmJiAhaXNNYXNrKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldEJ1ZmZlckVsZW1lbnQoYnVmZmVyLCBwb3NpdGlvbiwgZWxlbWVudCwgYXV0b1ByZXBhcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b1ByZXBhcmUpIHBvc2l0aW9uID0gcHJlcGFyZUJ1ZmZlcihidWZmZXIsIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gZ2V0QWN0aXZlVGVzdHMoKVtkZXRlcm1pbmVUZXN0UG9zaXRpb24ocG9zaXRpb24pXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gIT0gdW5kZWZpbmVkICYmIHRlc3QgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGVzdC5jYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cHBlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbWVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyW3Bvc2l0aW9uXSA9IGVsZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEJ1ZmZlckVsZW1lbnQoYnVmZmVyLCBwb3NpdGlvbiwgYXV0b1ByZXBhcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b1ByZXBhcmUpIHBvc2l0aW9uID0gcHJlcGFyZUJ1ZmZlcihidWZmZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9uZWVkZWQgdG8gaGFuZGxlIHRoZSBub24tZ3JlZWR5IG1hc2sgcmVwZXRpdGlvbnNcblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZUJ1ZmZlcihidWZmZXIsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltwb3NpdGlvbl0gPT0gdW5kZWZpbmVkICYmIGJ1ZmZlci5sZW5ndGggPCBnZXRNYXNrTGVuZ3RoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpW2pdICE9PSB1bmRlZmluZWQpIHsgLy9hZGQgYSBuZXcgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpW2orK10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB3cml0ZUJ1ZmZlcihpbnB1dCwgYnVmZmVyLCBjYXJldFBvcykge1xuICAgICAgICAgICAgICAgIGlucHV0Ll92YWx1ZVNldChidWZmZXIuam9pbignJykpO1xuICAgICAgICAgICAgICAgIGlmIChjYXJldFBvcyAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIGNhcmV0UG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGVuZCwgc3RyaXBOb21hc2tzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBtYXNrTCA9IGdldE1hc2tMZW5ndGgoKSA7IGkgPCBlbmQgJiYgaSA8IG1hc2tMOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwTm9tYXNrcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01hc2soaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnVmZmVyRWxlbWVudChidWZmZXIsIGksIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ1ZmZlckVsZW1lbnQoYnVmZmVyLCBpLCBnZXRCdWZmZXJFbGVtZW50KGdldEFjdGl2ZUJ1ZmZlclRlbXBsYXRlKCkuc2xpY2UoKSwgaSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0UmVUYXJnZXRQbGFjZUhvbGRlcihidWZmZXIsIHBvcykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0UG9zID0gZGV0ZXJtaW5lVGVzdFBvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICAgICAgc2V0QnVmZmVyRWxlbWVudChidWZmZXIsIHBvcywgZ2V0QnVmZmVyRWxlbWVudChnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpLCB0ZXN0UG9zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBsYWNlSG9sZGVyKHBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLnBsYWNlaG9sZGVyLmNoYXJBdChwb3MgJSBvcHRzLnBsYWNlaG9sZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrVmFsKGlucHV0LCB3cml0ZU91dCwgc3RyaWN0LCBucHR2bCwgaW50ZWxsaUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0VmFsdWUgPSBucHR2bCAhPSB1bmRlZmluZWQgPyBucHR2bC5zbGljZSgpIDogdHJ1bmNhdGVJbnB1dChpbnB1dC5fdmFsdWVHZXQoKSkuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgJC5lYWNoKG1hc2tzZXRzLCBmdW5jdGlvbiAobmR4LCBtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtcykgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNbXCJidWZmZXJcIl0gPSBtc1tcIl9idWZmZXJcIl0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zW1wicFwiXSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAhPT0gdHJ1ZSkgYWN0aXZlTWFza3NldEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAod3JpdGVPdXQpIGlucHV0Ll92YWx1ZVNldChcIlwiKTsgLy9pbml0aWFsIGNsZWFyXG4gICAgICAgICAgICAgICAgdmFyIG1sID0gZ2V0TWFza0xlbmd0aCgpO1xuICAgICAgICAgICAgICAgICQuZWFjaChpbnB1dFZhbHVlLCBmdW5jdGlvbiAobmR4LCBjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZWxsaUNoZWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGdldEFjdGl2ZU1hc2tTZXQoKVtcInBcIl0sIGx2cCA9IHAgPT0gLTEgPyBwIDogc2Vla1ByZXZpb3VzKHApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGx2cCA9PSAtMSA/IG5keCA6IHNlZWtOZXh0KGx2cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGNoYXJDb2RlLCBnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpLnNsaWNlKGx2cCArIDEsIHBvcykpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cHJlc3NFdmVudC5jYWxsKGlucHV0LCB1bmRlZmluZWQsIHRydWUsIGNoYXJDb2RlLmNoYXJDb2RlQXQoMCksIHdyaXRlT3V0LCBzdHJpY3QsIG5keCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlwcmVzc0V2ZW50LmNhbGwoaW5wdXQsIHVuZGVmaW5lZCwgdHJ1ZSwgY2hhckNvZGUuY2hhckNvZGVBdCgwKSwgd3JpdGVPdXQsIHN0cmljdCwgbmR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCA9PT0gdHJ1ZSAmJiBnZXRBY3RpdmVNYXNrU2V0KClbXCJwXCJdICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldEFjdGl2ZU1hc2tTZXQoKVtcImxhc3RWYWxpZFBvc2l0aW9uXCJdID0gc2Vla1ByZXZpb3VzKGdldEFjdGl2ZU1hc2tTZXQoKVtcInBcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuaW5wdXRtYXNrLmVzY2FwZVJlZ2V4LmNhbGwodGhpcywgc3RyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdHJ1bmNhdGVJbnB1dChpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKFwiICsgZXNjYXBlUmVnZXgoZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5qb2luKCcnKSkgKyBcIikqJFwiKSwgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyT3B0aW9uYWxUYWlsKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlcigpLCB0bXBCdWZmZXIgPSBidWZmZXIuc2xpY2UoKSwgdGVzdFBvcywgcG9zO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHRtcEJ1ZmZlci5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RQb3MgPSBkZXRlcm1pbmVUZXN0UG9zaXRpb24ocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdGl2ZVRlc3RzKClbdGVzdFBvc10ub3B0aW9uYWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNYXNrKHBvcykgfHwgIWlzVmFsaWQocG9zLCBidWZmZXJbcG9zXSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQnVmZmVyLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgdG1wQnVmZmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdW5tYXNrZWR2YWx1ZSgkaW5wdXQsIHNraXBEYXRlcGlja2VyQ2hlY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0QWN0aXZlVGVzdHMoKSAmJiAoc2tpcERhdGVwaWNrZXJDaGVjayA9PT0gdHJ1ZSB8fCAhJGlucHV0Lmhhc0NsYXNzKCdoYXNEYXRlcGlja2VyJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tWYWwoaW5wdXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVtVmFsdWUgPSAkLm1hcChnZXRBY3RpdmVCdWZmZXIoKSwgZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNYXNrKGluZGV4KSAmJiBpc1ZhbGlkKGluZGV4LCBlbGVtZW50LCB0cnVlKSA/IGVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVubWFza2VkVmFsdWUgPSAoaXNSVEwgPyB1bVZhbHVlLnJldmVyc2UoKSA6IHVtVmFsdWUpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5vblVuTWFzayAhPSB1bmRlZmluZWQgPyBvcHRzLm9uVW5NYXNrLmNhbGwodGhpcywgZ2V0QWN0aXZlQnVmZmVyKCkuam9pbignJyksIHVubWFza2VkVmFsdWUpIDogdW5tYXNrZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGlucHV0WzBdLl92YWx1ZUdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gVHJhbnNsYXRlUG9zaXRpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUlRMICYmIHR5cGVvZiBwb3MgPT0gJ251bWJlcicgJiYgKCFvcHRzLmdyZWVkeSB8fCBvcHRzLnBsYWNlaG9sZGVyICE9IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZmZyTGdodCA9IGdldEFjdGl2ZUJ1ZmZlcigpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gYmZmckxnaHQgLSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhcmV0KGlucHV0LCBiZWdpbiwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5wdCA9IGlucHV0LmpxdWVyeSAmJiBpbnB1dC5sZW5ndGggPiAwID8gaW5wdXRbMF0gOiBpbnB1dCwgcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IFRyYW5zbGF0ZVBvc2l0aW9uKGJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gVHJhbnNsYXRlUG9zaXRpb24oZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKGlucHV0KS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9ICh0eXBlb2YgZW5kID09ICdudW1iZXInKSA/IGVuZCA6IGJlZ2luO1xuICAgICAgICAgICAgICAgICAgICBucHQuc2Nyb2xsTGVmdCA9IG5wdC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuaW5zZXJ0TW9kZSA9PSBmYWxzZSAmJiBiZWdpbiA9PSBlbmQpIGVuZCsrOyAvL3NldCB2aXN1YWxpemF0aW9uIGZvciBpbnNlcnQvb3ZlcndyaXRlIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5wdC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnB0LnNlbGVjdGlvblN0YXJ0ID0gYmVnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBucHQuc2VsZWN0aW9uRW5kID0gYW5kcm9pZCA/IGJlZ2luIDogZW5kO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnB0LmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBucHQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIGJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKGlucHV0KS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgXCJiZWdpblwiOiAwLCBcImVuZFwiOiAwIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5wdC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBucHQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBucHQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IDAgLSByYW5nZS5kdXBsaWNhdGUoKS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC0xMDAwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gYmVnaW4gKyByYW5nZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IFRyYW5zbGF0ZVBvc2l0aW9uKGJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gVHJhbnNsYXRlUG9zaXRpb24oZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgXCJiZWdpblwiOiBiZWdpbiwgXCJlbmRcIjogZW5kIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0NvbXBsZXRlKGJ1ZmZlcikgeyAvL3JldHVybiB0cnVlIC8gZmFsc2UgLyB1bmRlZmluZWQgKHJlcGVhdCAqKVxuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlcGVhdCA9PSBcIipcIikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGUgPSBmYWxzZSwgaGlnaGVzdFZhbGlkUG9zaXRpb24gPSAwLCBjdXJyZW50QWN0aXZlTWFza3NldEluZGV4ID0gYWN0aXZlTWFza3NldEluZGV4O1xuICAgICAgICAgICAgICAgICQuZWFjaChtYXNrc2V0cywgZnVuY3Rpb24gKG5keCwgbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobXMpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IG5keDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbWwgPSBzZWVrUHJldmlvdXMoZ2V0TWFza0xlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc1tcImxhc3RWYWxpZFBvc2l0aW9uXCJdID49IGhpZ2hlc3RWYWxpZFBvc2l0aW9uICYmIG1zW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gPT0gYW1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGFtbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrID0gaXNNYXNrKGkpLCB0ZXN0UG9zID0gZGV0ZXJtaW5lVGVzdFBvc2l0aW9uKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG1hc2sgJiYgKGJ1ZmZlcltpXSA9PSB1bmRlZmluZWQgfHwgYnVmZmVyW2ldID09IGdldFBsYWNlSG9sZGVyKGkpKSkgfHwgKCFtYXNrICYmIGJ1ZmZlcltpXSAhPSBnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpW3Rlc3RQb3NdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSBjb21wbGV0ZSB8fCBtc0NvbXBsZXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkgLy9icmVhayBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RWYWxpZFBvc2l0aW9uID0gbXNbXCJsYXN0VmFsaWRQb3NpdGlvblwiXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IGN1cnJlbnRBY3RpdmVNYXNrc2V0SW5kZXg7IC8vcmVzZXQgYWN0aXZlTWFza3NldFxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNTZWxlY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1JUTCA/IChiZWdpbiAtIGVuZCkgPiAxIHx8ICgoYmVnaW4gLSBlbmQpID09IDEgJiYgb3B0cy5pbnNlcnRNb2RlKSA6XG4gICAgICAgICAgICAgICAgICAgIChlbmQgLSBiZWdpbikgPiAxIHx8ICgoZW5kIC0gYmVnaW4pID09IDEgJiYgb3B0cy5pbnNlcnRNb2RlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvL3ByaXZhdGUgZnVuY3Rpb25zXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnN0YWxsRXZlbnRSdWxlcihucHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gJC5fZGF0YShucHQpLmV2ZW50cztcblxuICAgICAgICAgICAgICAgICQuZWFjaChldmVudHMsIGZ1bmN0aW9uIChldmVudFR5cGUsIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGV2ZW50SGFuZGxlcnMsIGZ1bmN0aW9uIChuZHgsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlci5uYW1lc3BhY2UgPT0gXCJpbnB1dG1hc2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXIudHlwZSAhPSBcInNldHZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBldmVudEhhbmRsZXIuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE9ubHkgfHwgdGhpcy5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcGF0Y2hWYWx1ZVByb3BlcnR5KG5wdCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihucHQsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlUHJvcGVydHkgJiYgdmFsdWVQcm9wZXJ0eS5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFucHQuX3ZhbHVlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVHZXQgPSB2YWx1ZVByb3BlcnR5LmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVNldCA9IHZhbHVlUHJvcGVydHkuc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbnB0Ll92YWx1ZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSVEwgPyB2YWx1ZUdldC5jYWxsKHRoaXMpLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB2YWx1ZUdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5wdC5fdmFsdWVTZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNldC5jYWxsKHRoaXMsIGlzUlRMID8gdmFsdWUuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucHQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHNlbGYgPSAkKHRoaXMpLCBpbnB1dERhdGEgPSAkKHRoaXMpLmRhdGEoJ19pbnB1dG1hc2snKSwgbWFza3NldHMgPSBpbnB1dERhdGFbJ21hc2tzZXRzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSBpbnB1dERhdGFbJ2FjdGl2ZU1hc2tzZXRJbmRleCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXREYXRhICYmIGlucHV0RGF0YVsnb3B0cyddLmF1dG9Vbm1hc2sgPyAkc2VsZi5pbnB1dG1hc2soJ3VubWFza2VkdmFsdWUnKSA6IHZhbHVlR2V0LmNhbGwodGhpcykgIT0gbWFza3NldHNbYWN0aXZlTWFza3NldEluZGV4XVsnX2J1ZmZlciddLmpvaW4oJycpID8gdmFsdWVHZXQuY2FsbCh0aGlzKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3NldHZhbHVlLmlucHV0bWFzaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5fX2xvb2t1cEdldHRlcl9fICYmIG5wdC5fX2xvb2t1cEdldHRlcl9fKFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFucHQuX3ZhbHVlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVHZXQgPSBucHQuX19sb29rdXBHZXR0ZXJfXyhcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlU2V0ID0gbnB0Ll9fbG9va3VwU2V0dGVyX18oXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5wdC5fdmFsdWVHZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUlRMID8gdmFsdWVHZXQuY2FsbCh0aGlzKS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogdmFsdWVHZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBucHQuX3ZhbHVlU2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXQuY2FsbCh0aGlzLCBpc1JUTCA/IHZhbHVlLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBucHQuX19kZWZpbmVHZXR0ZXJfXyhcInZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHNlbGYgPSAkKHRoaXMpLCBpbnB1dERhdGEgPSAkKHRoaXMpLmRhdGEoJ19pbnB1dG1hc2snKSwgbWFza3NldHMgPSBpbnB1dERhdGFbJ21hc2tzZXRzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IGlucHV0RGF0YVsnYWN0aXZlTWFza3NldEluZGV4J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0RGF0YSAmJiBpbnB1dERhdGFbJ29wdHMnXS5hdXRvVW5tYXNrID8gJHNlbGYuaW5wdXRtYXNrKCd1bm1hc2tlZHZhbHVlJykgOiB2YWx1ZUdldC5jYWxsKHRoaXMpICE9IG1hc2tzZXRzW2FjdGl2ZU1hc2tzZXRJbmRleF1bJ19idWZmZXInXS5qb2luKCcnKSA/IHZhbHVlR2V0LmNhbGwodGhpcykgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnB0Ll9fZGVmaW5lU2V0dGVyX18oXCJ2YWx1ZVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdzZXR2YWx1ZS5pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFucHQuX3ZhbHVlR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBucHQuX3ZhbHVlR2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNSVEwgPyB0aGlzLnZhbHVlLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB0aGlzLnZhbHVlOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbnB0Ll92YWx1ZVNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLnZhbHVlID0gaXNSVEwgPyB2YWx1ZS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogdmFsdWU7IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCQudmFsSG9va3MudGV4dCA9PSB1bmRlZmluZWQgfHwgJC52YWxIb29rcy50ZXh0LmlucHV0bWFza3BhdGNoICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUdldCA9ICQudmFsSG9va3MudGV4dCAmJiAkLnZhbEhvb2tzLnRleHQuZ2V0ID8gJC52YWxIb29rcy50ZXh0LmdldCA6IGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnZhbHVlOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlU2V0ID0gJC52YWxIb29rcy50ZXh0ICYmICQudmFsSG9va3MudGV4dC5zZXQgPyAkLnZhbEhvb2tzLnRleHQuc2V0IDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCgkLnZhbEhvb2tzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRlbGVtLmRhdGEoJ19pbnB1dG1hc2snKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkZWxlbS5kYXRhKCdfaW5wdXRtYXNrJylbJ29wdHMnXS5hdXRvVW5tYXNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0uaW5wdXRtYXNrKCd1bm1hc2tlZHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZUdldChlbGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RGF0YSA9ICRlbGVtLmRhdGEoJ19pbnB1dG1hc2snKSwgbWFza3NldHMgPSBpbnB1dERhdGFbJ21hc2tzZXRzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSBpbnB1dERhdGFbJ2FjdGl2ZU1hc2tzZXRJbmRleCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9IG1hc2tzZXRzW2FjdGl2ZU1hc2tzZXRJbmRleF1bJ19idWZmZXInXS5qb2luKCcnKSA/IHJlc3VsdCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gdmFsdWVHZXQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlU2V0KGVsZW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkZWxlbS5kYXRhKCdfaW5wdXRtYXNrJykpICRlbGVtLnRyaWdnZXJIYW5kbGVyKCdzZXR2YWx1ZS5pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0bWFza3BhdGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2hpZnQgY2hhcnMgdG8gbGVmdCBmcm9tIHN0YXJ0IHRvIGVuZCBhbmQgcHV0IGMgYXQgZW5kIHBvc2l0aW9uIGlmIGRlZmluZWRcblxuICAgICAgICAgICAgZnVuY3Rpb24gc2hpZnRMKHN0YXJ0LCBlbmQsIGMsIG1hc2tKdW1wcykge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBnZXRBY3RpdmVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAobWFza0p1bXBzICE9PSBmYWxzZSkgLy9qdW1waW5nIG92ZXIgbm9ubWFzayBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTWFzayhzdGFydCkgJiYgc3RhcnQgLSAxID49IDApIHN0YXJ0LS07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kICYmIGkgPCBnZXRNYXNrTGVuZ3RoKCkgOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFzayhpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVUYXJnZXRQbGFjZUhvbGRlcihidWZmZXIsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBzZWVrTmV4dChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gZ2V0QnVmZmVyRWxlbWVudChidWZmZXIsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT0gZ2V0UGxhY2VIb2xkZXIoaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGdldE1hc2tMZW5ndGgoKSAmJiBpc1ZhbGlkKGksIHAsIHRydWUpICE9PSBmYWxzZSAmJiBnZXRBY3RpdmVUZXN0cygpW2RldGVybWluZVRlc3RQb3NpdGlvbihpKV0uZGVmID09IGdldEFjdGl2ZVRlc3RzKClbZGV0ZXJtaW5lVGVzdFBvc2l0aW9uKGopXS5kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnVmZmVyRWxlbWVudChidWZmZXIsIGksIHAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01hc2soaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZVRhcmdldFBsYWNlSG9sZGVyKGJ1ZmZlciwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgIT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBzZXRCdWZmZXJFbGVtZW50KGJ1ZmZlciwgc2Vla1ByZXZpb3VzKGVuZCksIGMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdldEFjdGl2ZU1hc2tTZXQoKVtcImdyZWVkeVwiXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJidWZmZXIgPSB0cnVuY2F0ZUlucHV0KGJ1ZmZlci5qb2luKCcnKSkuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoID0gdHJidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYmwgPSBidWZmZXIubGVuZ3RoOyBpIDwgYmw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gdHJidWZmZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gMCkgZ2V0QWN0aXZlTWFza1NldCgpW1wiYnVmZmVyXCJdID0gZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7IC8vcmV0dXJuIHRoZSB1c2VkIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNoaWZ0UihzdGFydCwgZW5kLCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRCdWZmZXJFbGVtZW50KGJ1ZmZlciwgc3RhcnQsIHRydWUpICE9IGdldFBsYWNlSG9sZGVyKHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc2Vla1ByZXZpb3VzKGVuZCkgOyBpID4gc3RhcnQgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01hc2soaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IHNlZWtQcmV2aW91cyhpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGdldEJ1ZmZlckVsZW1lbnQoYnVmZmVyLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAhPSBnZXRQbGFjZUhvbGRlcihqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChqLCB0LCB0cnVlKSAhPT0gZmFsc2UgJiYgZ2V0QWN0aXZlVGVzdHMoKVtkZXRlcm1pbmVUZXN0UG9zaXRpb24oaSldLmRlZiA9PSBnZXRBY3RpdmVUZXN0cygpW2RldGVybWluZVRlc3RQb3NpdGlvbihqKV0uZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCdWZmZXJFbGVtZW50KGJ1ZmZlciwgaSwgdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZVRhcmdldFBsYWNlSG9sZGVyKGJ1ZmZlciwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy9lbHNlIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlVGFyZ2V0UGxhY2VIb2xkZXIoYnVmZmVyLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyAhPSB1bmRlZmluZWQgJiYgZ2V0QnVmZmVyRWxlbWVudChidWZmZXIsIHN0YXJ0KSA9PSBnZXRQbGFjZUhvbGRlcihzdGFydCkpXG4gICAgICAgICAgICAgICAgICAgIHNldEJ1ZmZlckVsZW1lbnQoYnVmZmVyLCBzdGFydCwgYyk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aEJlZm9yZSA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGdldEFjdGl2ZU1hc2tTZXQoKVtcImdyZWVkeVwiXSA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJidWZmZXIgPSB0cnVuY2F0ZUlucHV0KGJ1ZmZlci5qb2luKCcnKSkuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoID0gdHJidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYmwgPSBidWZmZXIubGVuZ3RoOyBpIDwgYmw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gdHJidWZmZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gMCkgZ2V0QWN0aXZlTWFza1NldCgpW1wiYnVmZmVyXCJdID0gZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kIC0gKGxlbmd0aEJlZm9yZSAtIGJ1ZmZlci5sZW5ndGgpOyAvL3JldHVybiBuZXcgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gSGFuZGxlUmVtb3ZlKGlucHV0LCBrLCBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5udW1lcmljSW5wdXQgfHwgaXNSVEwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9wdHMua2V5Q29kZS5CQUNLU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IG9wdHMua2V5Q29kZS5ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9wdHMua2V5Q29kZS5ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IG9wdHMua2V5Q29kZS5CQUNLU1BBQ0U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVuZCA9IHBvcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MuZW5kID0gcG9zLmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmJlZ2luID0gcGVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpc1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5iZWdpbiA9PSBwb3MuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NCZWdpbiA9IGsgPT0gb3B0cy5rZXlDb2RlLkJBQ0tTUEFDRSA/IHBvcy5iZWdpbiAtIDEgOiBwb3MuYmVnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmlzTnVtZXJpYyAmJiBvcHRzLnJhZGl4UG9pbnQgIT0gXCJcIiAmJiBnZXRBY3RpdmVCdWZmZXIoKVtwb3NCZWdpbl0gPT0gb3B0cy5yYWRpeFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MuYmVnaW4gPSAoZ2V0QWN0aXZlQnVmZmVyKCkubGVuZ3RoIC0gMSA9PSBwb3NCZWdpbikgLyogcmFkaXhQb2ludCBpcyBsYXRlc3Q/IGRlbGV0ZSBpdCAqLyA/IHBvcy5iZWdpbiA6IGsgPT0gb3B0cy5rZXlDb2RlLkJBQ0tTUEFDRSA/IHBvc0JlZ2luIDogc2Vla05leHQocG9zQmVnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmVuZCA9IHBvcy5iZWdpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PSBvcHRzLmtleUNvZGUuQkFDS1NQQUNFKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmJlZ2luLS07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT0gb3B0cy5rZXlDb2RlLkRFTEVURSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5lbmQrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy5lbmQgLSBwb3MuYmVnaW4gPT0gMSAmJiAhb3B0cy5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09IG9wdHMua2V5Q29kZS5CQUNLU1BBQ0UpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MuYmVnaW4tLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGVhckJ1ZmZlcihnZXRBY3RpdmVCdWZmZXIoKSwgcG9zLmJlZ2luLCBwb3MuZW5kKTtcblxuICAgICAgICAgICAgICAgIHZhciBtbCA9IGdldE1hc2tMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5ncmVlZHkgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRMKHBvcy5iZWdpbiwgbWwsIHVuZGVmaW5lZCwgIWlzUlRMICYmIChrID09IG9wdHMua2V5Q29kZS5CQUNLU1BBQ0UgJiYgIWlzU2VsZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld3BvcyA9IHBvcy5iZWdpbjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBvcy5iZWdpbjsgaSA8IHBvcy5lbmQ7IGkrKykgeyAvL3NlZWtuZXh0IHRvIHNraXAgcGxhY2Vob2xkZXJzIGF0IHN0YXJ0IGluIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFzayhpKSB8fCAhaXNTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9zID0gc2hpZnRMKHBvcy5iZWdpbiwgbWwsIHVuZGVmaW5lZCwgIWlzUlRMICYmIChrID09IG9wdHMua2V5Q29kZS5CQUNLU1BBQ0UgJiYgIWlzU2VsZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGlvbikgcG9zLmJlZ2luID0gbmV3cG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RNYXNrUG9zID0gc2Vla05leHQoLTEpO1xuICAgICAgICAgICAgICAgIGNsZWFyQnVmZmVyKGdldEFjdGl2ZUJ1ZmZlcigpLCBwb3MuYmVnaW4sIHBvcy5lbmQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNoZWNrVmFsKGlucHV0LCBmYWxzZSwgbWFza3NldHNbMV0gPT0gdW5kZWZpbmVkIHx8IGZpcnN0TWFza1BvcyA+PSBwb3MuZW5kLCBnZXRBY3RpdmVCdWZmZXIoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEFjdGl2ZU1hc2tTZXQoKVsnbGFzdFZhbGlkUG9zaXRpb24nXSA8IGZpcnN0TWFza1Bvcykge1xuICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbXCJwXCJdID0gZmlyc3RNYXNrUG9zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldEFjdGl2ZU1hc2tTZXQoKVtcInBcIl0gPSBwb3MuYmVnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBrZXlkb3duRXZlbnQoZSkge1xuICAgICAgICAgICAgICAgIC8vU2FmYXJpIDUuMS54IC0gbW9kYWwgZGlhbG9nIGZpcmVzIGtleXByZXNzIHR3aWNlIHdvcmthcm91bmRcbiAgICAgICAgICAgICAgICBza2lwS2V5UHJlc3NFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMsICRpbnB1dCA9ICQoaW5wdXQpLCBrID0gZS5rZXlDb2RlLCBwb3MgPSBjYXJldChpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICAvL2JhY2tzcGFjZSwgZGVsZXRlLCBhbmQgZXNjYXBlIGdldCBzcGVjaWFsIHRyZWF0bWVudFxuICAgICAgICAgICAgICAgIGlmIChrID09IG9wdHMua2V5Q29kZS5CQUNLU1BBQ0UgfHwgayA9PSBvcHRzLmtleUNvZGUuREVMRVRFIHx8IChpcGhvbmUgJiYgayA9PSAxMjcpIHx8IGUuY3RybEtleSAmJiBrID09IDg4KSB7IC8vYmFja3NwYWNlL2RlbGV0ZVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vc3RvcCBkZWZhdWx0IGFjdGlvbiBidXQgYWxsb3cgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT0gODgpIHZhbHVlT25Gb2N1cyA9IGdldEFjdGl2ZUJ1ZmZlcigpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICBIYW5kbGVSZW1vdmUoaW5wdXQsIGssIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGRldGVybWluZUFjdGl2ZU1hc2tzZXRJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgZ2V0QWN0aXZlQnVmZmVyKCksIGdldEFjdGl2ZU1hc2tTZXQoKVtcInBcIl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuX3ZhbHVlR2V0KCkgPT0gZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5qb2luKCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKCdjbGVhcmVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc2hvd1Rvb2x0aXApIHsgLy91cGRhdGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnByb3AoXCJ0aXRsZVwiLCBnZXRBY3RpdmVNYXNrU2V0KClbXCJtYXNrXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PSBvcHRzLmtleUNvZGUuRU5EIHx8IGsgPT0gb3B0cy5rZXlDb2RlLlBBR0VfRE9XTikgeyAvL3doZW4gRU5EIG9yIFBBR0VfRE9XTiBwcmVzc2VkIHNldCBwb3NpdGlvbiBhdCBsYXN0bWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyZXRQb3MgPSBzZWVrTmV4dChnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdHMuaW5zZXJ0TW9kZSAmJiBjYXJldFBvcyA9PSBnZXRNYXNrTGVuZ3RoKCkgJiYgIWUuc2hpZnRLZXkpIGNhcmV0UG9zLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldChpbnB1dCwgZS5zaGlmdEtleSA/IHBvcy5iZWdpbiA6IGNhcmV0UG9zLCBjYXJldFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGsgPT0gb3B0cy5rZXlDb2RlLkhPTUUgJiYgIWUuc2hpZnRLZXkpIHx8IGsgPT0gb3B0cy5rZXlDb2RlLlBBR0VfVVApIHsgLy9Ib21lIG9yIHBhZ2VfdXBcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIDAsIGUuc2hpZnRLZXkgPyBwb3MuYmVnaW4gOiAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT0gb3B0cy5rZXlDb2RlLkVTQ0FQRSB8fCAoayA9PSA5MCAmJiBlLmN0cmxLZXkpKSB7IC8vZXNjYXBlICYmIHVuZG9cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tWYWwoaW5wdXQsIHRydWUsIGZhbHNlLCB2YWx1ZU9uRm9jdXMuc3BsaXQoJycpKTtcbiAgICAgICAgICAgICAgICAgICAgJGlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrID09IG9wdHMua2V5Q29kZS5JTlNFUlQgJiYgIShlLnNoaWZ0S2V5IHx8IGUuY3RybEtleSkpIHsgLy9pbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5pbnNlcnRNb2RlID0gIW9wdHMuaW5zZXJ0TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsICFvcHRzLmluc2VydE1vZGUgJiYgcG9zLmJlZ2luID09IGdldE1hc2tMZW5ndGgoKSA/IHBvcy5iZWdpbiAtIDEgOiBwb3MuYmVnaW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbnNlcnRNb2RlID09IGZhbHNlICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09IG9wdHMua2V5Q29kZS5SSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcmV0UG9zID0gY2FyZXQoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0KGlucHV0LCBjYXJldFBvcy5iZWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrID09IG9wdHMua2V5Q29kZS5MRUZUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyZXRQb3MgPSBjYXJldChpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIGNhcmV0UG9zLmJlZ2luIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q2FyZXRQb3MgPSBjYXJldChpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMub25LZXlEb3duLmNhbGwodGhpcywgZSwgZ2V0QWN0aXZlQnVmZmVyKCksIG9wdHMpID09PSB0cnVlKSAvL2V4dHJhIHN0dWZmIHRvIGV4ZWN1dGUgb24ga2V5ZG93blxuICAgICAgICAgICAgICAgICAgICBjYXJldChpbnB1dCwgY3VycmVudENhcmV0UG9zLmJlZ2luLCBjdXJyZW50Q2FyZXRQb3MuZW5kKTtcbiAgICAgICAgICAgICAgICBpZ25vcmFibGUgPSAkLmluQXJyYXkoaywgb3B0cy5pZ25vcmFibGVzKSAhPSAtMTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBmdW5jdGlvbiBrZXlwcmVzc0V2ZW50KGUsIGNoZWNrdmFsLCBrLCB3cml0ZU91dCwgc3RyaWN0LCBuZHgpIHtcbiAgICAgICAgICAgICAgICAvL1NhZmFyaSA1LjEueCAtIG1vZGFsIGRpYWxvZyBmaXJlcyBrZXlwcmVzcyB0d2ljZSB3b3JrYXJvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGsgPT0gdW5kZWZpbmVkICYmIHNraXBLZXlQcmVzc0V2ZW50KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2tpcEtleVByZXNzRXZlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcywgJGlucHV0ID0gJChpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBjaGVja3ZhbCA/IGsgOiAoZS53aGljaCB8fCBlLmNoYXJDb2RlIHx8IGUua2V5Q29kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2t2YWwgIT09IHRydWUgJiYgKCEoZS5jdHJsS2V5ICYmIGUuYWx0S2V5KSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBpZ25vcmFibGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zcGVjaWFsIHRyZWF0IHRoZSBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrdmFsICE9PSB0cnVlICYmIGsgPT0gNDYgJiYgZS5zaGlmdEtleSA9PSBmYWxzZSAmJiBvcHRzLnJhZGl4UG9pbnQgPT0gXCIsXCIpIGsgPSA0NDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcywgcmVzdWx0cywgcmVzdWx0LCBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwY2FyZXQgPSBzdHJpY3QgPyBuZHggOiBnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0geyBiZWdpbjogcGNhcmV0LCBlbmQ6IHBjYXJldCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjYXJldChpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkIHdlIGNsZWFyIGEgcG9zc2libGUgc2VsZWN0aW9uPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1NsY3RuID0gaXNTZWxlY3Rpb24ocG9zLmJlZ2luLCBwb3MuZW5kKSwgcmVkZXRlcm1pbmVMVlAgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSBhY3RpdmVNYXNrc2V0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTbGN0bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IGluaXRpYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gobWFza3NldHMsIGZ1bmN0aW9uIChuZHgsIGxtbnQpIHsgLy9pbml0IHVuZG9idWZmZXIgZm9yIHJlY292ZXJ5IHdoZW4gbm90IHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGxtbnQpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IG5keDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFjdGl2ZU1hc2tTZXQoKVtcInVuZG9CdWZmZXJcIl0gPSBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhhbmRsZVJlbW92ZShpbnB1dCwgb3B0cy5rZXlDb2RlLkRFTEVURSwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdHMuaW5zZXJ0TW9kZSkgeyAvL3ByZXNlcnZlIHNvbWUgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG1hc2tzZXRzLCBmdW5jdGlvbiAobmR4LCBsbW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChsbW50KSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWFza3NldEluZGV4ID0gbmR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0Uihwb3MuYmVnaW4sIGdldE1hc2tMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWN0aXZlTWFza1NldCgpW1wibGFzdFZhbGlkUG9zaXRpb25cIl0gPSBzZWVrTmV4dChnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSBpbml0aWFsSW5kZXg7IC8vcmVzdG9yZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaXhQb3NpdGlvbiA9IGdldEFjdGl2ZUJ1ZmZlcigpLmpvaW4oJycpLmluZGV4T2Yob3B0cy5yYWRpeFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmlzTnVtZXJpYyAmJiBjaGVja3ZhbCAhPT0gdHJ1ZSAmJiByYWRpeFBvc2l0aW9uICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZ3JlZWR5ICYmIHBvcy5iZWdpbiA8PSByYWRpeFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5iZWdpbiA9IHNlZWtQcmV2aW91cyhwb3MuYmVnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZW5kID0gcG9zLmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PSBvcHRzLnJhZGl4UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmJlZ2luID0gcmFkaXhQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmVuZCA9IHBvcy5iZWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwb3MuYmVnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gaXNWYWxpZChwLCBjLCBzdHJpY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCA9PT0gdHJ1ZSkgcmVzdWx0cyA9IFt7IFwiYWN0aXZlTWFza3NldEluZGV4XCI6IGFjdGl2ZU1hc2tzZXRJbmRleCwgXCJyZXN1bHRcIjogcmVzdWx0cyB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5pbWFsRm9yd2FyZFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKGluZGV4LCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSByZXN1bHRbXCJhY3RpdmVNYXNrc2V0SW5kZXhcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWN0aXZlTWFza1NldCgpW1wid3JpdGVPdXRCdWZmZXJcIl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBucCA9IHJlc3VsdFtcInJlc3VsdFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnAgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZyZXNoID0gZmFsc2UsIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnAgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBucFtcInJlZnJlc2hcIl07IC8vb25seSByZXdyaXRlIGJ1ZmZlciBmcm9tIGlzVmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBucC5wb3MgIT0gdW5kZWZpbmVkID8gbnAucG9zIDogcDsgLy9zZXQgbmV3IHBvc2l0aW9uIGZyb20gaXNWYWxpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5wLmMgIT0gdW5kZWZpbmVkID8gbnAuYyA6IGM7IC8vc2V0IG5ldyBjaGFyIGZyb20gaXNWYWxpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWZyZXNoICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5pbnNlcnRNb2RlID09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFVubWFza2VkUG9zaXRpb24gPSBnZXRNYXNrTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJmckNsb25lID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGdldEJ1ZmZlckVsZW1lbnQoYmZyQ2xvbmUsIGxhc3RVbm1hc2tlZFBvc2l0aW9uLCB0cnVlKSAhPSBnZXRQbGFjZUhvbGRlcihsYXN0VW5tYXNrZWRQb3NpdGlvbikgJiYgbGFzdFVubWFza2VkUG9zaXRpb24gPj0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VW5tYXNrZWRQb3NpdGlvbiA9IGxhc3RVbm1hc2tlZFBvc2l0aW9uID09IDAgPyAtMSA6IHNlZWtQcmV2aW91cyhsYXN0VW5tYXNrZWRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VW5tYXNrZWRQb3NpdGlvbiA+PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0UihwLCBnZXRNYXNrTGVuZ3RoKCksIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NoaWZ0IHRoZSBsdnAgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsdnAgPSBnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSwgbmx2cCA9IHNlZWtOZXh0KGx2cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChubHZwICE9IGdldE1hc2tMZW5ndGgoKSAmJiBsdnAgPj0gcCAmJiAoZ2V0QnVmZmVyRWxlbWVudChnZXRBY3RpdmVCdWZmZXIoKSwgbmx2cCwgdHJ1ZSkgIT0gZ2V0UGxhY2VIb2xkZXIobmx2cCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA9IG5sdnA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgZ2V0QWN0aXZlTWFza1NldCgpW1wid3JpdGVPdXRCdWZmZXJcIl0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzZXRCdWZmZXJFbGVtZW50KGJ1ZmZlciwgcCwgYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluaW1hbEZvcndhcmRQb3NpdGlvbiA9PSAtMSB8fCBtaW5pbWFsRm9yd2FyZFBvc2l0aW9uID4gc2Vla05leHQocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbWFsRm9yd2FyZFBvc2l0aW9uID0gc2Vla05leHQocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQb3MgPSBwIDwgZ2V0TWFza0xlbmd0aCgpID8gcCArIDEgOiBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltYWxGb3J3YXJkUG9zaXRpb24gPT0gLTEgfHwgbWluaW1hbEZvcndhcmRQb3NpdGlvbiA+IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbWFsRm9yd2FyZFBvc2l0aW9uID0gbmV4dFBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluaW1hbEZvcndhcmRQb3NpdGlvbiA+IGdldEFjdGl2ZU1hc2tTZXQoKVtcInBcIl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbXCJwXCJdID0gbWluaW1hbEZvcndhcmRQb3NpdGlvbjsgLy9uZWVkZWQgZm9yIGNoZWNrdmFsIHN0cmljdCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1hc2tzZXRJbmRleCA9IGluaXRpYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVBY3RpdmVNYXNrc2V0SW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cml0ZU91dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKG5keCwgcnNsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnNsdFtcImFjdGl2ZU1hc2tzZXRJbmRleFwiXSA9PSBhY3RpdmVNYXNrc2V0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJzbHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBvcHRzLm9uS2V5VmFsaWRhdGlvbi5jYWxsKHNlbGYsIHJlc3VsdFtcInJlc3VsdFwiXSwgb3B0cyk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QWN0aXZlTWFza1NldCgpW1wid3JpdGVPdXRCdWZmZXJcIl0gJiYgcmVzdWx0W1wicmVzdWx0XCJdICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q2FyZXRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhcmV0UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMubnVtZXJpY0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPiByYWRpeFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhcmV0UG9zaXRpb24gPSBzZWVrUHJldmlvdXMobWluaW1hbEZvcndhcmRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09IG9wdHMucmFkaXhQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYXJldFBvc2l0aW9uID0gbWluaW1hbEZvcndhcmRQb3NpdGlvbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIG5ld0NhcmV0UG9zaXRpb24gPSBzZWVrUHJldmlvdXMobWluaW1hbEZvcndhcmRQb3NpdGlvbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYXJldFBvc2l0aW9uID0gbWluaW1hbEZvcndhcmRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCdWZmZXIoaW5wdXQsIGJ1ZmZlciwgbmV3Q2FyZXRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2t2YWwgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy90aW1lb3V0IG5lZWRlZCBmb3IgSUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUoYnVmZmVyKSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnB1dEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NsY3RuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbXCJidWZmZXJcIl0gPSBnZXRBY3RpdmVNYXNrU2V0KClbXCJ1bmRvQnVmZmVyXCJdLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc2hvd1Rvb2x0aXApIHsgLy91cGRhdGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC5wcm9wKFwidGl0bGVcIiwgZ2V0QWN0aXZlTWFza1NldCgpW1wibWFza1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbmVlZGVkIGZvciBJRTggYW5kIGJlbG93XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCA/IGUucHJldmVudERlZmF1bHQoKSA6IGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5dXBFdmVudChlKSB7XG4gICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyksIGlucHV0ID0gdGhpcywgayA9IGUua2V5Q29kZSwgYnVmZmVyID0gZ2V0QWN0aXZlQnVmZmVyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5kcm9pZGNocm9tZSAmJiBrID09IG9wdHMua2V5Q29kZS5CQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocm9tZVZhbHVlT25JbnB1dCA9PSBpbnB1dC5fdmFsdWVHZXQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleWRvd25FdmVudC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9wdHMub25LZXlVcC5jYWxsKHRoaXMsIGUsIGJ1ZmZlciwgb3B0cyk7IC8vZXh0cmEgc3R1ZmYgdG8gZXhlY3V0ZSBvbiBrZXl1cFxuICAgICAgICAgICAgICAgIGlmIChrID09IG9wdHMua2V5Q29kZS5UQUIgJiYgb3B0cy5zaG93TWFza09uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dC5oYXNDbGFzcygnZm9jdXMuaW5wdXRtYXNrJykgJiYgaW5wdXQuX3ZhbHVlR2V0KCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlclRlbXBsYXRlKCkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQnVmZmVyKGlucHV0LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVPbkZvY3VzID0gZ2V0QWN0aXZlQnVmZmVyKCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIuam9pbignJykgPT0gZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5qb2luKCcnKSAmJiAkLmluQXJyYXkob3B0cy5yYWRpeFBvaW50LCBidWZmZXIpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIFRyYW5zbGF0ZVBvc2l0aW9uKDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0KGlucHV0LCBUcmFuc2xhdGVQb3NpdGlvbigwKSwgVHJhbnNsYXRlUG9zaXRpb24oZ2V0TWFza0xlbmd0aCgpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlucHV0RXZlbnQoZSkge1xuICAgICAgICAgICAgICAgIGlmIChza2lwSW5wdXRFdmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBza2lwSW5wdXRFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcywgJGlucHV0ID0gJChpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICBjaHJvbWVWYWx1ZU9uSW5wdXQgPSBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICBjaGVja1ZhbChpbnB1dCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgZ2V0QWN0aXZlQnVmZmVyKCkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlKGdldEFjdGl2ZUJ1ZmZlcigpKSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgJGlucHV0LnRyaWdnZXIoXCJjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgICAgICAkaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbWFzayhlbCkge1xuICAgICAgICAgICAgICAgICRlbCA9ICQoZWwpO1xuICAgICAgICAgICAgICAgIGlmICgkZWwuaXMoXCI6aW5wdXRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSB0ZXN0cyAmIG9yaWdpbmFsIGJ1ZmZlciBpbiB0aGUgaW5wdXQgZWxlbWVudCAtIHVzZWQgdG8gZ2V0IHRoZSB1bm1hc2tlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAkZWwuZGF0YSgnX2lucHV0bWFzaycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXNrc2V0cyc6IG1hc2tzZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZU1hc2tzZXRJbmRleCc6IGFjdGl2ZU1hc2tzZXRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRzJzogb3B0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpc1JUTCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2hvdyB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnNob3dUb29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWwucHJvcChcInRpdGxlXCIsIGdldEFjdGl2ZU1hc2tTZXQoKVtcIm1hc2tcIl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0IGdyZWVkeSBzZXR0aW5nIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBnZXRBY3RpdmVNYXNrU2V0KClbJ2dyZWVkeSddID0gZ2V0QWN0aXZlTWFza1NldCgpWydncmVlZHknXSA/IGdldEFjdGl2ZU1hc2tTZXQoKVsnZ3JlZWR5J10gOiBnZXRBY3RpdmVNYXNrU2V0KClbJ3JlcGVhdCddID09IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgbWF4bGVuZ3RoIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoJGVsLmF0dHIoXCJtYXhMZW5ndGhcIikgIT0gbnVsbCkgLy9vbmx5IHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9ICRlbC5wcm9wKCdtYXhMZW5ndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhMZW5ndGggPiAtMSkgeyAvL2hhbmRsZSAqLXJlcGVhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChtYXNrc2V0cywgZnVuY3Rpb24gKG5keCwgbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobXMpID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc1tcInJlcGVhdFwiXSA9PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zW1wicmVwZWF0XCJdID0gbWF4TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TWFza0xlbmd0aCgpID49IG1heExlbmd0aCAmJiBtYXhMZW5ndGggPiAtMSkgeyAvL0ZGIHNldHMgbm8gZGVmaW5lZCBtYXggbGVuZ3RoIHRvIC0xIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhMZW5ndGggPCBnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpLmxlbmd0aCkgZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5sZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdGl2ZU1hc2tTZXQoKVsnZ3JlZWR5J10gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWN0aXZlTWFza1NldCgpWydyZXBlYXQnXSA9IE1hdGgucm91bmQobWF4TGVuZ3RoIC8gZ2V0QWN0aXZlQnVmZmVyVGVtcGxhdGUoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZWwucHJvcCgnbWF4TGVuZ3RoJywgZ2V0TWFza0xlbmd0aCgpICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXRjaFZhbHVlUHJvcGVydHkoZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLm51bWVyaWNJbnB1dCkgb3B0cy5pc051bWVyaWMgPSBvcHRzLm51bWVyaWNJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmRpciA9PSBcInJ0bFwiIHx8IChvcHRzLm51bWVyaWNJbnB1dCAmJiBvcHRzLnJpZ2h0QWxpZ25OdW1lcmljcykgfHwgKG9wdHMuaXNOdW1lcmljICYmIG9wdHMucmlnaHRBbGlnbk51bWVyaWNzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbC5jc3MoXCJ0ZXh0LWFsaWduXCIsIFwicmlnaHRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmRpciA9PSBcInJ0bFwiIHx8IG9wdHMubnVtZXJpY0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5kaXIgPSBcImx0clwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLnJlbW92ZUF0dHIoXCJkaXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXREYXRhID0gJGVsLmRhdGEoJ19pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RGF0YVsnaXNSVEwnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWwuZGF0YSgnX2lucHV0bWFzaycsIGlucHV0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JUTCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3VuYmluZCBhbGwgZXZlbnRzIC0gdG8gbWFrZSBzdXJlIHRoYXQgbm8gb3RoZXIgbWFzayB3aWxsIGludGVyZmVyZSB3aGVuIHJlLW1hc2tpbmdcbiAgICAgICAgICAgICAgICAgICAgJGVsLnVuYmluZChcIi5pbnB1dG1hc2tcIik7XG4gICAgICAgICAgICAgICAgICAgICRlbC5yZW1vdmVDbGFzcygnZm9jdXMuaW5wdXRtYXNrJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vYmluZCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgJGVsLmNsb3Nlc3QoJ2Zvcm0nKS5iaW5kKFwic3VibWl0XCIsIGZ1bmN0aW9uICgpIHsgLy90cmlnZ2VyIGNoYW5nZSBvbiBzdWJtaXQgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVPbkZvY3VzICE9IGdldEFjdGl2ZUJ1ZmZlcigpLmpvaW4oJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5iaW5kKCdyZXNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC50cmlnZ2VyKFwic2V0dmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICRlbC5iaW5kKFwibW91c2VlbnRlci5pbnB1dG1hc2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyksIGlucHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJGlucHV0Lmhhc0NsYXNzKCdmb2N1cy5pbnB1dG1hc2snKSAmJiBvcHRzLnNob3dNYXNrT25Ib3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5fdmFsdWVHZXQoKSAhPSBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgZ2V0QWN0aXZlQnVmZmVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkuYmluZChcImJsdXIuaW5wdXRtYXNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKHRoaXMpLCBpbnB1dCA9IHRoaXMsIG5wdFZhbHVlID0gaW5wdXQuX3ZhbHVlR2V0KCksIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnJlbW92ZUNsYXNzKCdmb2N1cy5pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZU9uRm9jdXMgIT0gZ2V0QWN0aXZlQnVmZmVyKCkuam9pbignJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5jbGVhck1hc2tPbkxvc3RGb2N1cyAmJiBucHRWYWx1ZSAhPSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucHRWYWx1ZSA9PSBnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpLmpvaW4oJycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5fdmFsdWVTZXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvL2NsZWFyb3V0IG9wdGlvbmFsIHRhaWwgb2YgdGhlIG1hc2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJPcHRpb25hbFRhaWwoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlKGJ1ZmZlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnRyaWdnZXIoXCJpbmNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNsZWFySW5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gobWFza3NldHMsIGZ1bmN0aW9uIChuZHgsIG1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtcykgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zW1wiYnVmZmVyXCJdID0gbXNbXCJfYnVmZmVyXCJdLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlTWFza3NldEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5fdmFsdWVTZXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGdldEFjdGl2ZUJ1ZmZlclRlbXBsYXRlKCkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQnVmZmVyKGlucHV0LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS5iaW5kKFwiZm9jdXMuaW5wdXRtYXNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKHRoaXMpLCBpbnB1dCA9IHRoaXMsIG5wdFZhbHVlID0gaW5wdXQuX3ZhbHVlR2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5zaG93TWFza09uRm9jdXMgJiYgISRpbnB1dC5oYXNDbGFzcygnZm9jdXMuaW5wdXRtYXNrJykgJiYgKCFvcHRzLnNob3dNYXNrT25Ib3ZlciB8fCAob3B0cy5zaG93TWFza09uSG92ZXIgJiYgbnB0VmFsdWUgPT0gJycpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5fdmFsdWVHZXQoKSAhPSBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihpbnB1dCwgZ2V0QWN0aXZlQnVmZmVyKCksIHNlZWtOZXh0KGdldEFjdGl2ZU1hc2tTZXQoKVtcImxhc3RWYWxpZFBvc2l0aW9uXCJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LmFkZENsYXNzKCdmb2N1cy5pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlT25Gb2N1cyA9IGdldEFjdGl2ZUJ1ZmZlcigpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB9KS5iaW5kKFwibW91c2VsZWF2ZS5pbnB1dG1hc2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyksIGlucHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNsZWFyTWFza09uTG9zdEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkaW5wdXQuaGFzQ2xhc3MoJ2ZvY3VzLmlucHV0bWFzaycpICYmIGlucHV0Ll92YWx1ZUdldCgpICE9ICRpbnB1dC5hdHRyKFwicGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Ll92YWx1ZUdldCgpID09IGdldEFjdGl2ZUJ1ZmZlclRlbXBsYXRlKCkuam9pbignJykgfHwgaW5wdXQuX3ZhbHVlR2V0KCkgPT0gJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5fdmFsdWVTZXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy9jbGVhcm91dCBvcHRpb25hbCB0YWlsIG9mIHRoZSBtYXNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhck9wdGlvbmFsVGFpbChpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLmJpbmQoXCJjbGljay5pbnB1dG1hc2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZENhcmV0ID0gY2FyZXQoaW5wdXQpLCBidWZmZXIgPSBnZXRBY3RpdmVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRDYXJldC5iZWdpbiA9PSBzZWxlY3RlZENhcmV0LmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpY2tQb3NpdGlvbiA9IGlzUlRMID8gVHJhbnNsYXRlUG9zaXRpb24oc2VsZWN0ZWRDYXJldC5iZWdpbikgOiBzZWxlY3RlZENhcmV0LmJlZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbHZwID0gZ2V0QWN0aXZlTWFza1NldCgpW1wibGFzdFZhbGlkUG9zaXRpb25cIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmlzTnVtZXJpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvc2l0aW9uID0gb3B0cy5za2lwUmFkaXhEYW5jZSA9PT0gZmFsc2UgJiYgb3B0cy5yYWRpeFBvaW50ICE9IFwiXCIgJiYgJC5pbkFycmF5KG9wdHMucmFkaXhQb2ludCwgYnVmZmVyKSAhPSAtMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMubnVtZXJpY0lucHV0ID8gc2Vla05leHQoJC5pbkFycmF5KG9wdHMucmFkaXhQb2ludCwgYnVmZmVyKSkgOiAkLmluQXJyYXkob3B0cy5yYWRpeFBvaW50LCBidWZmZXIpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vla05leHQobHZwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbiA9IHNlZWtOZXh0KGx2cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrUG9zaXRpb24gPCBsYXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01hc2soY2xpY2tQb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIGNsaWNrUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBjYXJldChpbnB1dCwgc2Vla05leHQoY2xpY2tQb3NpdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0KGlucHV0LCBsYXN0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB9KS5iaW5kKCdkYmxjbGljay5pbnB1dG1hc2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXQoaW5wdXQsIDAsIHNlZWtOZXh0KGdldEFjdGl2ZU1hc2tTZXQoKVtcImxhc3RWYWxpZFBvc2l0aW9uXCJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuYmluZChwYXN0ZUV2ZW50ICsgXCIuaW5wdXRtYXNrIGRyYWdkcm9wLmlucHV0bWFzayBkcm9wLmlucHV0bWFza1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBJbnB1dEV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcElucHV0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMsICRpbnB1dCA9ICQoaW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Bhc3RlIGV2ZW50IGZvciBJRTggYW5kIGxvd2VyIEkgZ3Vlc3MgOy0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09IFwicHJvcGVydHljaGFuZ2VcIiAmJiBpbnB1dC5fdmFsdWVHZXQoKS5sZW5ndGggPD0gZ2V0TWFza0xlbmd0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFzdGVWYWx1ZSA9IG9wdHMub25CZWZvcmVQYXN0ZSAhPSB1bmRlZmluZWQgPyBvcHRzLm9uQmVmb3JlUGFzdGUuY2FsbCh0aGlzLCBpbnB1dC5fdmFsdWVHZXQoKSkgOiBpbnB1dC5fdmFsdWVHZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1ZhbChpbnB1dCwgdHJ1ZSwgZmFsc2UsIHBhc3RlVmFsdWUuc3BsaXQoJycpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wbGV0ZShnZXRBY3RpdmVCdWZmZXIoKSkgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC50cmlnZ2VyKFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuYmluZCgnc2V0dmFsdWUuaW5wdXRtYXNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVmFsKGlucHV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlT25Gb2N1cyA9IGdldEFjdGl2ZUJ1ZmZlcigpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Ll92YWx1ZUdldCgpID09IGdldEFjdGl2ZUJ1ZmZlclRlbXBsYXRlKCkuam9pbignJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuX3ZhbHVlU2V0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuYmluZCgnY29tcGxldGUuaW5wdXRtYXNrJywgb3B0cy5vbmNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgICkuYmluZCgnaW5jb21wbGV0ZS5pbnB1dG1hc2snLCBvcHRzLm9uaW5jb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICApLmJpbmQoJ2NsZWFyZWQuaW5wdXRtYXNrJywgb3B0cy5vbmNsZWFyZWRcbiAgICAgICAgICAgICAgICAgICAgKS5iaW5kKFwia2V5dXAuaW5wdXRtYXNrXCIsIGtleXVwRXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmRyb2lkY2hyb21lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWwuYmluZChcImlucHV0LmlucHV0bWFza1wiLCBpbnB1dEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbC5iaW5kKFwia2V5ZG93bi5pbnB1dG1hc2tcIiwga2V5ZG93bkV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICApLmJpbmQoXCJrZXlwcmVzcy5pbnB1dG1hc2tcIiwga2V5cHJlc3NFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobXNpZTEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmJpbmQoXCJpbnB1dC5pbnB1dG1hc2tcIiwgaW5wdXRFdmVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBtYXNrXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrVmFsKGVsLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlT25Gb2N1cyA9IGdldEFjdGl2ZUJ1ZmZlcigpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYSB0cnkvY2F0Y2ggYmxvY2sgc2luY2UgSUU5IHRocm93IFwiVW5zcGVjaWZpZWQgZXJyb3JcIiBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVuZGVmaW5lZCB3aGVuIHdlIGFyZSBpbiBhbiBJRnJhbWUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZWwpIHsgLy9wb3NpdGlvbiB0aGUgY2FyZXQgd2hlbiBpbiBmb2N1c1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmFkZENsYXNzKCdmb2N1cy5pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0KGVsLCBzZWVrTmV4dChnZXRBY3RpdmVNYXNrU2V0KClbXCJsYXN0VmFsaWRQb3NpdGlvblwiXSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuY2xlYXJNYXNrT25Mb3N0Rm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKSA9PSBnZXRBY3RpdmVCdWZmZXJUZW1wbGF0ZSgpLmpvaW4oJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuX3ZhbHVlU2V0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJPcHRpb25hbFRhaWwoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVCdWZmZXIoZWwsIGdldEFjdGl2ZUJ1ZmZlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxFdmVudFJ1bGVyKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vYWN0aW9uIG9iamVjdFxuICAgICAgICAgICAgaWYgKGFjdGlvbk9iaiAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbk9ialtcImFjdGlvblwiXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXNDb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQ29tcGxldGUoYWN0aW9uT2JqW1wiYnVmZmVyXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVubWFza2VkdmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUlRMID0gYWN0aW9uT2JqW1wiJGlucHV0XCJdLmRhdGEoJ19pbnB1dG1hc2snKVsnaXNSVEwnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bm1hc2tlZHZhbHVlKGFjdGlvbk9ialtcIiRpbnB1dFwiXSwgYWN0aW9uT2JqW1wic2tpcERhdGVwaWNrZXJDaGVja1wiXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrKGFjdGlvbk9ialtcImVsXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybWF0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAkZWwgPSAkKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbC5kYXRhKCdfaW5wdXRtYXNrJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXNrc2V0cyc6IG1hc2tzZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmVNYXNrc2V0SW5kZXgnOiBhY3RpdmVNYXNrc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29wdHMnOiBvcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpc1JUTCc6IG9wdHMubnVtZXJpY0lucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLm51bWVyaWNJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuaXNOdW1lcmljID0gb3B0cy5udW1lcmljSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSVEwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1ZhbCgkZWwsIGZhbHNlLCBmYWxzZSwgYWN0aW9uT2JqW1widmFsdWVcIl0uc3BsaXQoJycpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRBY3RpdmVCdWZmZXIoKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJC5pbnB1dG1hc2sgPSB7XG4gICAgICAgICAgICAvL29wdGlvbnMgZGVmYXVsdFxuICAgICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJfXCIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxtYXJrZXI6IHsgc3RhcnQ6IFwiW1wiLCBlbmQ6IFwiXVwiIH0sXG4gICAgICAgICAgICAgICAgcXVhbnRpZmllcm1hcmtlcjogeyBzdGFydDogXCJ7XCIsIGVuZDogXCJ9XCIgfSxcbiAgICAgICAgICAgICAgICBncm91cG1hcmtlcjogeyBzdGFydDogXCIoXCIsIGVuZDogXCIpXCIgfSxcbiAgICAgICAgICAgICAgICBlc2NhcGVDaGFyOiBcIlxcXFxcIixcbiAgICAgICAgICAgICAgICBtYXNrOiBudWxsLFxuICAgICAgICAgICAgICAgIG9uY29tcGxldGU6ICQubm9vcCwgLy9leGVjdXRlcyB3aGVuIHRoZSBtYXNrIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgb25pbmNvbXBsZXRlOiAkLm5vb3AsIC8vZXhlY3V0ZXMgd2hlbiB0aGUgbWFzayBpcyBpbmNvbXBsZXRlIGFuZCBmb2N1cyBpcyBsb3N0XG4gICAgICAgICAgICAgICAgb25jbGVhcmVkOiAkLm5vb3AsIC8vZXhlY3V0ZXMgd2hlbiB0aGUgbWFzayBpcyBjbGVhcmVkXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAwLCAvL3JlcGV0aXRpb25zIG9mIHRoZSBtYXNrOiAqIH4gZm9yZXZlciwgb3RoZXJ3aXNlIHNwZWNpZnkgYW4gaW50ZWdlclxuICAgICAgICAgICAgICAgIGdyZWVkeTogdHJ1ZSwgLy90cnVlOiBhbGxvY2F0ZWQgYnVmZmVyIGZvciB0aGUgbWFzayBhbmQgcmVwZXRpdGlvbnMgLSBmYWxzZTogYWxsb2NhdGUgb25seSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBhdXRvVW5tYXNrOiBmYWxzZSwgLy9hdXRvbWF0aWNhbGx5IHVubWFzayB3aGVuIHJldHJpZXZpbmcgdGhlIHZhbHVlIHdpdGggJC5mbi52YWwgb3IgdmFsdWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgX19sb29rdXBHZXR0ZXJfXyBvciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgICAgICAgICAgICBjbGVhck1hc2tPbkxvc3RGb2N1czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnNlcnRNb2RlOiB0cnVlLCAvL2luc2VydCB0aGUgaW5wdXQgb3Igb3ZlcndyaXRlIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIGNsZWFySW5jb21wbGV0ZTogZmFsc2UsIC8vY2xlYXIgdGhlIGluY29tcGxldGUgaW5wdXQgb24gYmx1clxuICAgICAgICAgICAgICAgIGFsaWFzZXM6IHt9LCAvL2FsaWFzZXMgZGVmaW5pdGlvbnMgPT4gc2VlIGpxdWVyeS5pbnB1dG1hc2suZXh0ZW5zaW9ucy5qc1xuICAgICAgICAgICAgICAgIG9uS2V5VXA6ICQubm9vcCwgLy9vdmVycmlkZSB0byBpbXBsZW1lbnQgYXV0b2NvbXBsZXRlIG9uIGNlcnRhaW4ga2V5cyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogJC5ub29wLCAvL292ZXJyaWRlIHRvIGltcGxlbWVudCBhdXRvY29tcGxldGUgb24gY2VydGFpbiBrZXlzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgICAgb25CZWZvcmVQYXN0ZTogdW5kZWZpbmVkLCAvL2V4ZWN1dGVzIGJlZm9yZSBtYXNraW5nIHRoZSBwYXN0ZWQgdmFsdWUgdG8gYWxsb3cgcHJlcHJvY2Vzc2luZyBvZiB0aGUgcGFzdGVkIHZhbHVlLiAgYXJncyA9PiBwYXN0ZWRWYWx1ZSA9PiByZXR1cm4gcHJvY2Vzc2VkVmFsdWVcbiAgICAgICAgICAgICAgICBvblVuTWFzazogdW5kZWZpbmVkLCAvL2V4ZWN1dGVzIGFmdGVyIHVubWFza2luZyB0byBhbGxvdyBwb3N0cHJvY2Vzc2luZyBvZiB0aGUgdW5tYXNrZWR2YWx1ZS4gIGFyZ3MgPT4gbWFza2VkVmFsdWUsIHVubWFza2VkVmFsdWVcbiAgICAgICAgICAgICAgICBzaG93TWFza09uRm9jdXM6IHRydWUsIC8vc2hvdyB0aGUgbWFzay1wbGFjZWhvbGRlciB3aGVuIHRoZSBpbnB1dCBoYXMgZm9jdXNcbiAgICAgICAgICAgICAgICBzaG93TWFza09uSG92ZXI6IHRydWUsIC8vc2hvdyB0aGUgbWFzay1wbGFjZWhvbGRlciB3aGVuIGhvdmVyaW5nIHRoZSBlbXB0eSBpbnB1dFxuICAgICAgICAgICAgICAgIG9uS2V5VmFsaWRhdGlvbjogJC5ub29wLCAvL2V4ZWN1dGVzIG9uIGV2ZXJ5IGtleS1wcmVzcyB3aXRoIHRoZSByZXN1bHQgb2YgaXNWYWxpZC4gUGFyYW1zOiByZXN1bHQsIG9wdHNcbiAgICAgICAgICAgICAgICBza2lwT3B0aW9uYWxQYXJ0Q2hhcmFjdGVyOiBcIiBcIiwgLy9hIGNoYXJhY3RlciB3aGljaCBjYW4gYmUgdXNlZCB0byBza2lwIGFuIG9wdGlvbmFsIHBhcnQgb2YgYSBtYXNrXG4gICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IGZhbHNlLCAvL3Nob3cgdGhlIGFjdGl2ZW1hc2sgYXMgdG9vbHRpcFxuICAgICAgICAgICAgICAgIG51bWVyaWNJbnB1dDogZmFsc2UsIC8vbnVtZXJpY0lucHV0IGlucHV0IGRpcmVjdGlvbiBzdHlsZSAoaW5wdXQgc2hpZnRzIHRvIHRoZSBsZWZ0IHdoaWxlIGhvbGRpbmcgdGhlIGNhcmV0IHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIC8vbnVtZXJpYyBiYXNpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgaXNOdW1lcmljOiBmYWxzZSwgLy9lbmFibGUgbnVtZXJpYyBmZWF0dXJlc1xuICAgICAgICAgICAgICAgIHJhZGl4UG9pbnQ6IFwiXCIsIC8vXCIuXCIsIC8vIHwgXCIsXCJcbiAgICAgICAgICAgICAgICBza2lwUmFkaXhEYW5jZTogZmFsc2UsIC8vZGlzYWJsZSByYWRpeHBvaW50IGNhcmV0IHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAgICAgcmlnaHRBbGlnbk51bWVyaWNzOiB0cnVlLCAvL2FsaWduIG51bWVyaWNzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgICAgIC8vbnVtZXJpYyBiYXNpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJzknOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IFwiWzAtOV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5OiAxXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIltBLVphLXpcXHUwNDEwLVxcdTA0NEZcXHUwNDAxXFx1MDQ1MV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5OiAxXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICcqJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBcIltBLVphLXpcXHUwNDEwLVxcdTA0NEZcXHUwNDAxXFx1MDQ1MTAtOV1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5OiAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGtleUNvZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgQUxUOiAxOCwgQkFDS1NQQUNFOiA4LCBDQVBTX0xPQ0s6IDIwLCBDT01NQTogMTg4LCBDT01NQU5EOiA5MSwgQ09NTUFORF9MRUZUOiA5MSwgQ09NTUFORF9SSUdIVDogOTMsIENPTlRST0w6IDE3LCBERUxFVEU6IDQ2LCBET1dOOiA0MCwgRU5EOiAzNSwgRU5URVI6IDEzLCBFU0NBUEU6IDI3LCBIT01FOiAzNiwgSU5TRVJUOiA0NSwgTEVGVDogMzcsIE1FTlU6IDkzLCBOVU1QQURfQUREOiAxMDcsIE5VTVBBRF9ERUNJTUFMOiAxMTAsIE5VTVBBRF9ESVZJREU6IDExMSwgTlVNUEFEX0VOVEVSOiAxMDgsXG4gICAgICAgICAgICAgICAgICAgIE5VTVBBRF9NVUxUSVBMWTogMTA2LCBOVU1QQURfU1VCVFJBQ1Q6IDEwOSwgUEFHRV9ET1dOOiAzNCwgUEFHRV9VUDogMzMsIFBFUklPRDogMTkwLCBSSUdIVDogMzksIFNISUZUOiAxNiwgU1BBQ0U6IDMyLCBUQUI6IDksIFVQOiAzOCwgV0lORE9XUzogOTFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vc3BlY2lmeSBrZXljb2RlcyB3aGljaCBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgaW4gdGhlIGtleXByZXNzIGV2ZW50LCBvdGhlcndpc2UgdGhlIHByZXZlbnREZWZhdWx0IHdpbGwgc3RvcCB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIGVzcGVjaWFsbHkgaW4gRkZcbiAgICAgICAgICAgICAgICBpZ25vcmFibGVzOiBbOCwgOSwgMTMsIDE5LCAyNywgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0NSwgNDYsIDkzLCAxMTIsIDExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsIDExOSwgMTIwLCAxMjEsIDEyMiwgMTIzXSxcbiAgICAgICAgICAgICAgICBnZXRNYXNrTGVuZ3RoOiBmdW5jdGlvbiAoYnVmZmVyLCBncmVlZHksIHJlcGVhdCwgY3VycmVudEJ1ZmZlciwgb3B0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlZExlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JlZWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0ID09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZExlbmd0aCA9IGN1cnJlbnRCdWZmZXIubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVwZWF0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRMZW5ndGggKz0gKGJ1ZmZlci5sZW5ndGggKiAocmVwZWF0IC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlc2NhcGVSZWdleDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjaWFscyA9IFsnLycsICcuJywgJyonLCAnKycsICc/JywgJ3wnLCAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCddO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCcoXFxcXCcgKyBzcGVjaWFscy5qb2luKCd8XFxcXCcpICsgJyknLCAnZ2ltJyksICdcXFxcJDEnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQodHJ1ZSwge30sICQuaW5wdXRtYXNrLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQWxpYXMob3B0cy5hbGlhcywgb3B0aW9ucywgb3B0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hc2tTY29wZShnZW5lcmF0ZU1hc2tTZXRzKG9wdHMpLCAwLCBvcHRzLCB7IFwiYWN0aW9uXCI6IFwiZm9ybWF0XCIsIFwidmFsdWVcIjogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5mbi5pbnB1dG1hc2sgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQodHJ1ZSwge30sICQuaW5wdXRtYXNrLmRlZmF1bHRzLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBtYXNrc2V0cyxcbiAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWFza1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXNvbHZlIHBvc3NpYmxlIGFsaWFzZXMgZ2l2ZW4gYnkgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUFsaWFzKG9wdHMuYWxpYXMsIG9wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza3NldHMgPSBnZW5lcmF0ZU1hc2tTZXRzKG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tzZXRzLmxlbmd0aCA9PSAwKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tTY29wZSgkLmV4dGVuZCh0cnVlLCB7fSwgbWFza3NldHMpLCAwLCBvcHRzLCB7IFwiYWN0aW9uXCI6IFwibWFza1wiLCBcImVsXCI6IHRoaXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVubWFza2VkdmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKHRoaXMpLCBpbnB1dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0LmRhdGEoJ19pbnB1dG1hc2snKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tzZXRzID0gJGlucHV0LmRhdGEoJ19pbnB1dG1hc2snKVsnbWFza3NldHMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSAkaW5wdXQuZGF0YSgnX2lucHV0bWFzaycpWydhY3RpdmVNYXNrc2V0SW5kZXgnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gJGlucHV0LmRhdGEoJ19pbnB1dG1hc2snKVsnb3B0cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXNrU2NvcGUobWFza3NldHMsIGFjdGl2ZU1hc2tzZXRJbmRleCwgb3B0cywgeyBcImFjdGlvblwiOiBcInVubWFza2VkdmFsdWVcIiwgXCIkaW5wdXRcIjogJGlucHV0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiAkaW5wdXQudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKHRoaXMpLCBpbnB1dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dC5kYXRhKCdfaW5wdXRtYXNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza3NldHMgPSAkaW5wdXQuZGF0YSgnX2lucHV0bWFzaycpWydtYXNrc2V0cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSAkaW5wdXQuZGF0YSgnX2lucHV0bWFzaycpWydhY3RpdmVNYXNrc2V0SW5kZXgnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9ICRpbnB1dC5kYXRhKCdfaW5wdXRtYXNrJylbJ29wdHMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cml0ZW91dCB0aGUgdW5tYXNrZWR2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5fdmFsdWVTZXQobWFza1Njb3BlKG1hc2tzZXRzLCBhY3RpdmVNYXNrc2V0SW5kZXgsIG9wdHMsIHsgXCJhY3Rpb25cIjogXCJ1bm1hc2tlZHZhbHVlXCIsIFwiJGlucHV0XCI6ICRpbnB1dCwgXCJza2lwRGF0ZXBpY2tlckNoZWNrXCI6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NsZWFyIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnJlbW92ZURhdGEoJ19pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91bmJpbmQgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW5wdXQudW5iaW5kKFwiLmlucHV0bWFza1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LnJlbW92ZUNsYXNzKCdmb2N1cy5pbnB1dG1hc2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXN0b3JlIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbnB1dCwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlUHJvcGVydHkgJiYgdmFsdWVQcm9wZXJ0eS5nZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5fdmFsdWVHZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGlucHV0Ll92YWx1ZUdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBpbnB1dC5fdmFsdWVTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5fX2xvb2t1cEdldHRlcl9fICYmIGlucHV0Ll9fbG9va3VwR2V0dGVyX18oXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Ll92YWx1ZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Ll9fZGVmaW5lR2V0dGVyX18oXCJ2YWx1ZVwiLCBpbnB1dC5fdmFsdWVHZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Ll9fZGVmaW5lU2V0dGVyX18oXCJ2YWx1ZVwiLCBpbnB1dC5fdmFsdWVTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7IC8vdHJ5IGNhdGNoIG5lZWRlZCBmb3IgSUU3IGFzIGl0IGRvZXMgbm90IHN1cHBvcnRzIGRlbGV0aW5nIGZuc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGlucHV0Ll92YWx1ZUdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnB1dC5fdmFsdWVTZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Ll92YWx1ZUdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0Ll92YWx1ZVNldCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldGVtcHR5bWFza1wiOiAvL3JldHVybiB0aGUgZGVmYXVsdCAoZW1wdHkpIG1hc2sgdmFsdWUsIHVzZWZ1bGwgZm9yIHNldHRpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaW4gdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSgnX2lucHV0bWFzaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza3NldHMgPSB0aGlzLmRhdGEoJ19pbnB1dG1hc2snKVsnbWFza3NldHMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSB0aGlzLmRhdGEoJ19pbnB1dG1hc2snKVsnYWN0aXZlTWFza3NldEluZGV4J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hc2tzZXRzW2FjdGl2ZU1hc2tzZXRJbmRleF1bJ19idWZmZXInXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoYXNNYXNrZWRWYWx1ZVwiOiAvL2NoZWNrIHdoZXRlciB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgbWFza2VkIG9yIG5vdDsgY3VycmVudGx5IG9ubHkgd29ya3MgcmVsaWFibGUgd2hlbiB1c2luZyBqcXVlcnkudmFsIGZuIHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ19pbnB1dG1hc2snKSA/ICF0aGlzLmRhdGEoJ19pbnB1dG1hc2snKVsnb3B0cyddLmF1dG9Vbm1hc2sgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlzQ29tcGxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tzZXRzID0gdGhpcy5kYXRhKCdfaW5wdXRtYXNrJylbJ21hc2tzZXRzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSB0aGlzLmRhdGEoJ19pbnB1dG1hc2snKVsnYWN0aXZlTWFza3NldEluZGV4J107XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gdGhpcy5kYXRhKCdfaW5wdXRtYXNrJylbJ29wdHMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXNrU2NvcGUobWFza3NldHMsIGFjdGl2ZU1hc2tzZXRJbmRleCwgb3B0cywgeyBcImFjdGlvblwiOiBcImlzQ29tcGxldGVcIiwgXCJidWZmZXJcIjogdGhpc1swXS5fdmFsdWVHZXQoKS5zcGxpdCgnJykgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRtZXRhZGF0YVwiOiAvL3JldHVybiBtYXNrIG1ldGFkYXRhIGlmIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YSgnX2lucHV0bWFzaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza3NldHMgPSB0aGlzLmRhdGEoJ19pbnB1dG1hc2snKVsnbWFza3NldHMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVNYXNrc2V0SW5kZXggPSB0aGlzLmRhdGEoJ19pbnB1dG1hc2snKVsnYWN0aXZlTWFza3NldEluZGV4J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hc2tzZXRzW2FjdGl2ZU1hc2tzZXRJbmRleF1bJ21ldGFkYXRhJ107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBmbiBpcyBhbiBhbGlhc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlQWxpYXMoZm4sIG9wdGlvbnMsIG9wdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYXliZSBmbiBpcyBhIG1hc2sgc28gd2UgdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgbWFza1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMubWFzayA9IGZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza3NldHMgPSBnZW5lcmF0ZU1hc2tTZXRzKG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tzZXRzLmxlbmd0aCA9PSAwKSB7IHJldHVybiB0aGlzOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrU2NvcGUoJC5leHRlbmQodHJ1ZSwge30sIG1hc2tzZXRzKSwgYWN0aXZlTWFza3NldEluZGV4LCBvcHRzLCB7IFwiYWN0aW9uXCI6IFwibWFza1wiLCBcImVsXCI6IHRoaXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm4gPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5pbnB1dG1hc2suZGVmYXVsdHMsIGZuKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmVBbGlhcyhvcHRzLmFsaWFzLCBmbiwgb3B0cyk7IC8vcmVzb2x2ZSBhbGlhc2VzXG4gICAgICAgICAgICAgICAgbWFza3NldHMgPSBnZW5lcmF0ZU1hc2tTZXRzKG9wdHMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrc2V0cy5sZW5ndGggPT0gMCkgeyByZXR1cm4gdGhpczsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrU2NvcGUoJC5leHRlbmQodHJ1ZSwge30sIG1hc2tzZXRzKSwgYWN0aXZlTWFza3NldEluZGV4LCBvcHRzLCB7IFwiYWN0aW9uXCI6IFwibWFza1wiLCBcImVsXCI6IHRoaXMgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZuID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vbG9vayBmb3IgZGF0YS1pbnB1dG1hc2sgYXRyaWJ1dGUgLSB0aGUgYXR0cmlidXRlIHNob3VsZCBvbmx5IGNvbnRhaW4gb3B0aXBuc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ck9wdGlvbnMgPSAkKHRoaXMpLmF0dHIoXCJkYXRhLWlucHV0bWFza1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJPcHRpb25zICYmIGF0dHJPcHRpb25zICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ck9wdGlvbnMgPSBhdHRyT3B0aW9ucy5yZXBsYWNlKG5ldyBSZWdFeHAoXCInXCIsIFwiZ1wiKSwgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFvcHRpb25zID0gJC5wYXJzZUpTT04oXCJ7XCIgKyBhdHRyT3B0aW9ucyArIFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBkYXRhb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkLmlucHV0bWFzay5kZWZhdWx0cywgZGF0YW9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVBbGlhcyhvcHRzLmFsaWFzLCBkYXRhb3B0aW9ucywgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5hbGlhcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmlucHV0bWFzayhvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7IH0gLy9uZWVkIGEgbW9yZSByZWxheCBwYXJzZUpTT05cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pKGpRdWVyeSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9ib3dlci9BZG1pbkxURS9wbHVnaW5zL2lucHV0LW1hc2svanF1ZXJ5LmlucHV0bWFzay5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

eval("/*\nInput Mask plugin extensions\nhttp://github.com/RobinHerbots/jquery.inputmask\nCopyright (c) 2010 - 2014 Robin Herbots\nLicensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\nVersion: 0.0.0\n\nRegex extensions on the jquery.inputmask base\nAllows for using regular expressions as a mask\n*/\n(function ($) {\n    $.extend($.inputmask.defaults.aliases, { // $(selector).inputmask(\"Regex\", { regex: \"[0-9]*\"}\n        'Regex': {\n            mask: \"r\",\n            greedy: false,\n            repeat: \"*\",\n            regex: null,\n            regexTokens: null,\n            //Thx to https://github.com/slevithan/regex-colorizer for the tokenizer regex\n            tokenizer: /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\n            quantifierFilter: /[0-9]+[^,]/,\n            definitions: {\n                'r': {\n                    validator: function (chrs, buffer, pos, strict, opts) {\n                        function regexToken() {\n                            this.matches = [];\n                            this.isGroup = false;\n                            this.isQuantifier = false;\n                            this.isLiteral = false;\n                        }\n                        function analyseRegex() {\n                            var currentToken = new regexToken(), match, m, opengroups = [];\n\n                            opts.regexTokens = [];\n\n                            // The tokenizer regex does most of the tokenization grunt work\n                            while (match = opts.tokenizer.exec(opts.regex)) {\n                                m = match[0];\n                                switch (m.charAt(0)) {\n                                    case \"[\": // Character class\n                                    case \"\\\\\":  // Escape or backreference\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(m);\n                                        } else {\n                                            currentToken.matches.push(m);\n                                        }\n                                        break;\n                                    case \"(\": // Group opening\n                                        if (!currentToken.isGroup && currentToken.matches.length > 0)\n                                            opts.regexTokens.push(currentToken);\n                                        currentToken = new regexToken();\n                                        currentToken.isGroup = true;\n                                        opengroups.push(currentToken);\n                                        break;\n                                    case \")\": // Group closing\n                                        var groupToken = opengroups.pop();\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(groupToken);\n                                        } else {\n                                            opts.regexTokens.push(groupToken);\n                                            currentToken = new regexToken();\n                                        }\n                                        break;\n                                    case \"{\": //Quantifier\n                                        var quantifier = new regexToken();\n                                        quantifier.isQuantifier = true;\n                                        quantifier.matches.push(m);\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(quantifier);\n                                        } else {\n                                            currentToken.matches.push(quantifier);\n                                        }\n                                        break;\n                                    default:\n                                        // Vertical bar (alternator) \n                                        // ^ or $ anchor\n                                        // Dot (.)\n                                        // Literal character sequence\n                                        var literal = new regexToken();\n                                        literal.isLiteral = true;\n                                        literal.matches.push(m);\n                                        if (opengroups.length > 0) {\n                                            opengroups[opengroups.length - 1][\"matches\"].push(literal);\n                                        } else {\n                                            currentToken.matches.push(literal);\n                                        }\n                                }\n                            }\n\n                            if (currentToken.matches.length > 0)\n                                opts.regexTokens.push(currentToken);\n                        }\n                        function validateRegexToken(token, fromGroup) {\n                            var isvalid = false;\n                            if (fromGroup) {\n                                regexPart += \"(\";\n                                openGroupCount++;\n                            }\n                            for (var mndx = 0; mndx < token[\"matches\"].length; mndx++) {\n                                var matchToken = token[\"matches\"][mndx];\n                                if (matchToken[\"isGroup\"] == true) {\n                                    isvalid = validateRegexToken(matchToken, true);\n                                } else if (matchToken[\"isQuantifier\"] == true) {\n                                    matchToken = matchToken[\"matches\"][0];\n                                    var quantifierMax = opts.quantifierFilter.exec(matchToken)[0].replace(\"}\", \"\");\n                                    var testExp = regexPart + \"{1,\" + quantifierMax + \"}\"; //relax quantifier validation\n                                    for (var j = 0; j < openGroupCount; j++) {\n                                        testExp += \")\";\n                                    }\n                                    var exp = new RegExp(\"^(\" + testExp + \")$\");\n                                    isvalid = exp.test(bufferStr);\n                                    regexPart += matchToken;\n                                } else if (matchToken[\"isLiteral\"] == true) {\n                                    matchToken = matchToken[\"matches\"][0];\n                                    var testExp = regexPart, openGroupCloser = \"\";\n                                    for (var j = 0; j < openGroupCount; j++) {\n                                        openGroupCloser += \")\";\n                                    }\n                                    for (var k = 0; k < matchToken.length; k++) { //relax literal validation\n                                        testExp = (testExp + matchToken[k]).replace(/\\|$/, \"\");\n                                        var exp = new RegExp(\"^(\" + testExp + openGroupCloser + \")$\");\n                                        isvalid = exp.test(bufferStr);\n                                        if (isvalid) break;\n                                    }\n                                    regexPart += matchToken;\n                                    //console.log(bufferStr + \" \" + exp + \" \" + isvalid);\n                                } else {\n                                    regexPart += matchToken;\n                                    var testExp = regexPart.replace(/\\|$/, \"\");\n                                    for (var j = 0; j < openGroupCount; j++) {\n                                        testExp += \")\";\n                                    }\n                                    var exp = new RegExp(\"^(\" + testExp + \")$\");\n                                    isvalid = exp.test(bufferStr);\n                                    //console.log(bufferStr + \" \" + exp + \" \" + isvalid);\n                                }\n                                if (isvalid) break;\n                            }\n\n                            if (fromGroup) {\n                                regexPart += \")\";\n                                openGroupCount--;\n                            }\n\n                            return isvalid;\n                        }\n\n\n                        if (opts.regexTokens == null) {\n                            analyseRegex();\n                        }\n\n                        var cbuffer = buffer.slice(), regexPart = \"\", isValid = false, openGroupCount = 0;\n                        cbuffer.splice(pos, 0, chrs);\n                        var bufferStr = cbuffer.join('');\n                        for (var i = 0; i < opts.regexTokens.length; i++) {\n                            var regexToken = opts.regexTokens[i];\n                            isValid = validateRegexToken(regexToken, regexToken[\"isGroup\"]);\n                            if (isValid) break;\n                        }\n\n                        return isValid;\n                    },\n                    cardinality: 1\n                }\n            }\n        }\n    });\n})(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2Jvd2VyL0FkbWluTFRFL3BsdWdpbnMvaW5wdXQtbWFzay9qcXVlcnkuaW5wdXRtYXNrLnJlZ2V4LmV4dGVuc2lvbnMuanM/MDAxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuSW5wdXQgTWFzayBwbHVnaW4gZXh0ZW5zaW9uc1xuaHR0cDovL2dpdGh1Yi5jb20vUm9iaW5IZXJib3RzL2pxdWVyeS5pbnB1dG1hc2tcbkNvcHlyaWdodCAoYykgMjAxMCAtIDIwMTQgUm9iaW4gSGVyYm90c1xuTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcblZlcnNpb246IDAuMC4wXG5cblJlZ2V4IGV4dGVuc2lvbnMgb24gdGhlIGpxdWVyeS5pbnB1dG1hc2sgYmFzZVxuQWxsb3dzIGZvciB1c2luZyByZWd1bGFyIGV4cHJlc3Npb25zIGFzIGEgbWFza1xuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgICQuZXh0ZW5kKCQuaW5wdXRtYXNrLmRlZmF1bHRzLmFsaWFzZXMsIHsgLy8gJChzZWxlY3RvcikuaW5wdXRtYXNrKFwiUmVnZXhcIiwgeyByZWdleDogXCJbMC05XSpcIn1cbiAgICAgICAgJ1JlZ2V4Jzoge1xuICAgICAgICAgICAgbWFzazogXCJyXCIsXG4gICAgICAgICAgICBncmVlZHk6IGZhbHNlLFxuICAgICAgICAgICAgcmVwZWF0OiBcIipcIixcbiAgICAgICAgICAgIHJlZ2V4OiBudWxsLFxuICAgICAgICAgICAgcmVnZXhUb2tlbnM6IG51bGwsXG4gICAgICAgICAgICAvL1RoeCB0byBodHRwczovL2dpdGh1Yi5jb20vc2xldml0aGFuL3JlZ2V4LWNvbG9yaXplciBmb3IgdGhlIHRva2VuaXplciByZWdleFxuICAgICAgICAgICAgdG9rZW5pemVyOiAvXFxbXFxeP10/KD86W15cXFxcXFxdXSt8XFxcXFtcXFNcXHNdPykqXT98XFxcXCg/OjAoPzpbMC0zXVswLTddezAsMn18WzQtN11bMC03XT8pP3xbMS05XVswLTldKnx4WzAtOUEtRmEtZl17Mn18dVswLTlBLUZhLWZdezR9fGNbQS1aYS16XXxbXFxTXFxzXT8pfFxcKCg/OlxcP1s6PSFdPyk/fCg/Ols/KitdfFxce1swLTldKyg/OixbMC05XSopP1xcfSlcXD8/fFteLj8qK14ke1soKXxcXFxcXSt8Li9nLFxuICAgICAgICAgICAgcXVhbnRpZmllckZpbHRlcjogL1swLTldK1teLF0vLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAncic6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiAoY2hycywgYnVmZmVyLCBwb3MsIHN0cmljdCwgb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVnZXhUb2tlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUXVhbnRpZmllciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbmFseXNlUmVnZXgoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IG5ldyByZWdleFRva2VuKCksIG1hdGNoLCBtLCBvcGVuZ3JvdXBzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnJlZ2V4VG9rZW5zID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdG9rZW5pemVyIHJlZ2V4IGRvZXMgbW9zdCBvZiB0aGUgdG9rZW5pemF0aW9uIGdydW50IHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBvcHRzLnRva2VuaXplci5leGVjKG9wdHMucmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIltcIjogLy8gQ2hhcmFjdGVyIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOiAgLy8gRXNjYXBlIG9yIGJhY2tyZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3Blbmdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ncm91cHNbb3Blbmdyb3Vwcy5sZW5ndGggLSAxXVtcIm1hdGNoZXNcIl0ucHVzaChtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4ubWF0Y2hlcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6IC8vIEdyb3VwIG9wZW5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRUb2tlbi5pc0dyb3VwICYmIGN1cnJlbnRUb2tlbi5tYXRjaGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMucmVnZXhUb2tlbnMucHVzaChjdXJyZW50VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IG5ldyByZWdleFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuLmlzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ncm91cHMucHVzaChjdXJyZW50VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIilcIjogLy8gR3JvdXAgY2xvc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cFRva2VuID0gb3Blbmdyb3Vwcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3Blbmdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ncm91cHNbb3Blbmdyb3Vwcy5sZW5ndGggLSAxXVtcIm1hdGNoZXNcIl0ucHVzaChncm91cFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnJlZ2V4VG9rZW5zLnB1c2goZ3JvdXBUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IG5ldyByZWdleFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIntcIjogLy9RdWFudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1YW50aWZpZXIgPSBuZXcgcmVnZXhUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aWZpZXIuaXNRdWFudGlmaWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGlmaWVyLm1hdGNoZXMucHVzaChtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3Blbmdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ncm91cHNbb3Blbmdyb3Vwcy5sZW5ndGggLSAxXVtcIm1hdGNoZXNcIl0ucHVzaChxdWFudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4ubWF0Y2hlcy5wdXNoKHF1YW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljYWwgYmFyIChhbHRlcm5hdG9yKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBeIG9yICQgYW5jaG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG90ICguKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpdGVyYWwgY2hhcmFjdGVyIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBuZXcgcmVnZXhUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwuaXNMaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsLm1hdGNoZXMucHVzaChtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3Blbmdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ncm91cHNbb3Blbmdyb3Vwcy5sZW5ndGggLSAxXVtcIm1hdGNoZXNcIl0ucHVzaChsaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4ubWF0Y2hlcy5wdXNoKGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4ubWF0Y2hlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnJlZ2V4VG9rZW5zLnB1c2goY3VycmVudFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUmVnZXhUb2tlbih0b2tlbiwgZnJvbUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4UGFydCArPSBcIihcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Blbkdyb3VwQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbW5keCA9IDA7IG1uZHggPCB0b2tlbltcIm1hdGNoZXNcIl0ubGVuZ3RoOyBtbmR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoVG9rZW4gPSB0b2tlbltcIm1hdGNoZXNcIl1bbW5keF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFRva2VuW1wiaXNHcm91cFwiXSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3ZhbGlkID0gdmFsaWRhdGVSZWdleFRva2VuKG1hdGNoVG9rZW4sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoVG9rZW5bXCJpc1F1YW50aWZpZXJcIl0gPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hUb2tlbiA9IG1hdGNoVG9rZW5bXCJtYXRjaGVzXCJdWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1YW50aWZpZXJNYXggPSBvcHRzLnF1YW50aWZpZXJGaWx0ZXIuZXhlYyhtYXRjaFRva2VuKVswXS5yZXBsYWNlKFwifVwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0RXhwID0gcmVnZXhQYXJ0ICsgXCJ7MSxcIiArIHF1YW50aWZpZXJNYXggKyBcIn1cIjsgLy9yZWxheCBxdWFudGlmaWVyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3Blbkdyb3VwQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RFeHAgKz0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwID0gbmV3IFJlZ0V4cChcIl4oXCIgKyB0ZXN0RXhwICsgXCIpJFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzdmFsaWQgPSBleHAudGVzdChidWZmZXJTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhQYXJ0ICs9IG1hdGNoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hUb2tlbltcImlzTGl0ZXJhbFwiXSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFRva2VuID0gbWF0Y2hUb2tlbltcIm1hdGNoZXNcIl1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEV4cCA9IHJlZ2V4UGFydCwgb3Blbkdyb3VwQ2xvc2VyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3Blbkdyb3VwQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Hcm91cENsb3NlciArPSBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWF0Y2hUb2tlbi5sZW5ndGg7IGsrKykgeyAvL3JlbGF4IGxpdGVyYWwgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RFeHAgPSAodGVzdEV4cCArIG1hdGNoVG9rZW5ba10pLnJlcGxhY2UoL1xcfCQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwID0gbmV3IFJlZ0V4cChcIl4oXCIgKyB0ZXN0RXhwICsgb3Blbkdyb3VwQ2xvc2VyICsgXCIpJFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3ZhbGlkID0gZXhwLnRlc3QoYnVmZmVyU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXN2YWxpZCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFBhcnQgKz0gbWF0Y2hUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coYnVmZmVyU3RyICsgXCIgXCIgKyBleHAgKyBcIiBcIiArIGlzdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhQYXJ0ICs9IG1hdGNoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEV4cCA9IHJlZ2V4UGFydC5yZXBsYWNlKC9cXHwkLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wZW5Hcm91cENvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0RXhwICs9IFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgdGVzdEV4cCArIFwiKSRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3ZhbGlkID0gZXhwLnRlc3QoYnVmZmVyU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coYnVmZmVyU3RyICsgXCIgXCIgKyBleHAgKyBcIiBcIiArIGlzdmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3ZhbGlkKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4UGFydCArPSBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Blbkdyb3VwQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXN2YWxpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5yZWdleFRva2VucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5hbHlzZVJlZ2V4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYnVmZmVyID0gYnVmZmVyLnNsaWNlKCksIHJlZ2V4UGFydCA9IFwiXCIsIGlzVmFsaWQgPSBmYWxzZSwgb3Blbkdyb3VwQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2J1ZmZlci5zcGxpY2UocG9zLCAwLCBjaHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXJTdHIgPSBjYnVmZmVyLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnJlZ2V4VG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4VG9rZW4gPSBvcHRzLnJlZ2V4VG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZGF0ZVJlZ2V4VG9rZW4ocmVnZXhUb2tlbiwgcmVnZXhUb2tlbltcImlzR3JvdXBcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsaXR5OiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KShqUXVlcnkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvYm93ZXIvQWRtaW5MVEUvcGx1Z2lucy9pbnB1dC1tYXNrL2pxdWVyeS5pbnB1dG1hc2sucmVnZXguZXh0ZW5zaW9ucy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(1);
__webpack_require__(0);
module.exports = __webpack_require__(2);


/***/ }
/******/ ]);